### 재발방지책 #78: 통신 표준화 — 단일 창구와 최소 JSlib 표면적 유지
- **원인**: Unity ↔ Web 통신 경로가 분산되고, C#에서 여러 DllImport를 호출하면서 시그니처 불일치/스트리핑으로 런타임 오류가 빈발.
- **조치**:
  - JSlib은 오직 3개 함수만 유지: `InitPostMessageListenerInternal`, `SendMessageToWebInternal`, `NotifySceneTransitionCompleteInternal`.
  - Unity C# 전체에서 웹 송신은 반드시 `SocketManager.SendMessageToWeb(type, data)`만 사용.
  - React가 Socket.IO의 유일한 소유자. Unity는 모든 서버 송수신을 React에 위임.
- **검증**:
  - WebGL 산출물의 실제 제공 파일(`public/unity/Build/unity.framework.js`)에 금지 심볼(예: `ConnectToSocketIOServer`, `EmitToServer`, `SendMessageToWebSafe`, `ForceReinitializeJavaScriptFunctionsInternal`)이 존재하지 않을 것.
  - C#에서 위 금지 심볼 DllImport/호출이 없을 것.
- **재발 방지**: 새로운 통신 요구가 생겨도 JSlib 함수 추가 금지. Unity → React → 서버의 단방향 표준을 유지한다.

### 재발방지책 #79: 핸드셰이크 견고화 — init 재전송/ACK 루프와 씬 전환 트리거
- **원인**: 로딩/씬 전환 타이밍 경쟁으로 `init` 수신 누락 → 역할 미설정, 무한 대기/롤백.
- **조치**:
  - React `UnityPage.tsx`에서 `init` 메시지 전송 후 1.5초 간격, 최대 20회 재전송. `init-complete` 수신 시 즉시 중단.
  - Unity가 `unity-loaded`, `unity-ready`을 보낼 때 React는 `init`을 재전송한다. 단, `sceneTransitionComplete` 수신 시에는 이미 `init-complete`가 수신된 경우 `init` 재전송을 스킵한다.
  - 동일 씬 재로드 금지: `BootLoader.LoadSceneBasedOnRole`는 현재 활성 씬과 동일하면 `LoadScene` 호출하지 않는다. `isInitialized`가 true면 역할 재설정 시에도 씬 재로드를 건너뛴다.
  - JSlib 메시지 큐로 Unity 인스턴스 준비 전 메시지 유실 방지, 준비 시 일괄 flush.
- **검증**: 브라우저 콘솔 기준 5초 내 `unity-ready → init → init-complete` 순서가 안정적으로 관측될 것.
- **재발 방지**: 씬 전환 관련 신규 로직 추가 시에도 위 트리거/ACK 루프를 절대 제거하지 않는다.

### 재발방지책 #80: 빌드/배포 일관성 — 개발 빌드 설정과 캐시 무효화 절차 고정
- **원인**: 압축/스트리핑, 캐시된 구버전 산출물로 JS 함수 테이블 누락 → `null function or signature mismatch` 재발.
- **조치(개발용 설정 고정)**:
  - WebGL Player Settings: Compression Format = Disabled, Managed Stripping Level = Disabled, Strip Engine Code = Off, Script Call Optimization = Slow and Safe, Exceptions = Full.
  - WebGL 템플릿: `<!-- UNITY_JSLIB_PLUGINS -->` 훅 유지. 빌드 파일 경로에 `?v=timestamp`를 부여하여 캐시 무효화(최소 `framework/data/wasm`).
  - 배포: 항상 `public/unity` 폴더를 비운 뒤 Unity 산출물(`index.html` + `Build/`)을 전체 교체. 개발 서버 재기동 후 브라우저 DevTools에서 Disable cache + Hard Reload.
- **검증**:
  - 네트워크 탭에서 `unity.framework.js`/`unity.wasm`이 200(OK)로 새로 내려오고(304 아님), 실제 파일 타임스탬프가 최신인지 확인.
  - 런타임에서 금지 심볼 호출 스택이 더 이상 보이지 않을 것.
- **재발 방지**: Settings 변경/플러그인 추가 시, 위 체크리스트를 PR 템플릿의 필수 확인 항목으로 포함한다.

### 재발방지책 #81: 안전 JSON 및 NRE 방지 — 직렬화/역직렬화와 참조 가드
- 원인: 잘못된 JSON(문자열 따옴표 누락)으로 `JsonUtility.FromJson<T>`가 null을 반환하거나, 씬 로드 시점에 참조가 비어 NRE 발생.
- 조치:
  - Unity 직렬화는 항상 `JsonHelper.DictionaryToJsonSafe` 사용. 문자열/특수문자 이스케이프와 따옴표 보장.
  - 역직렬화 후 null 검사 필수. null이면 조기 리턴 및 경고 로그, 후속 로직 금지.
  - 컴포넌트 참조(`questionController`, `gameStateManager`)는 재바인딩 코루틴 완료 후 접근. 모든 접근 전 null 가드.
  - 이벤트/코루틴은 씬 언로드 시 해제. 파괴된 오브젝트에서 콜백 실행 금지.
- 검증: 브라우저 콘솔의 Unity → Web 메시지에서 data JSON이 올바른 따옴표를 포함. NRE 스택이 더 이상 재현되지 않음.

### 재발방지책 #82: 씬 완료 알림 단일화/디바운스 — 중복 통지로 인한 루프/예외 방지
- 원인: 씬 완료 알림이 여러 경로에서 중복 호출되어 `sceneTransitionComplete`가 반복 전송, 씬 경계에서 파괴된 오브젝트 접근으로 NRE 유발.
- 조치:
  - 알림 경로 단일화: `OnSceneLoaded → SafeInitializeAfterSceneLoad → NotifySceneTransitionCompleteDelayed`만 사용. `LoadSceneBasedOnRole`에서는 알림 코루틴을 시작하지 않음.
  - 디바운스 플래그: `currentSceneName`, `lastNotifiedScene`, `notifyInFlight`, `notifyCoroutine` 관리로 동일 씬에 대해 1회만 통지. 진행 중이면 새 코루틴 시작 금지.
  - 정리: `OnSceneUnloaded/OnDestroy`에서 코루틴 중지와 이벤트 구독 해제.
- 검증: 동일 씬에 대해 `sceneTransitionComplete` 로그가 1회만 발생. React는 `init-complete` 이후 재초기화를 트리거하지 않음.


