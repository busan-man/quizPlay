# Unity WebGL 통신 재발방지책 가이드

**버전:** 4.3  
**총 재발방지책 수:** 77  
**최종 업데이트:** 2025년 8월

## 목차
1. [기본 설정](#기본-설정)
2. [통신 문제](#통신-문제)
3. [성능 문제](#성능-문제)
4. [디버깅](#디버깅)
5. [최신 문제 해결](#최신-문제-해결)

---

## 기본 설정

### 재발방지책 #1: Unity WebGL 빌드 설정
**문제:** WebGL 빌드에서 통신이 안됨  
**해결책:**
- Build Settings → Platform → WebGL 선택
- Player Settings → Publishing Settings → Compression Format: Disabled
- Player Settings → Publishing Settings → Enable Exceptions: Full

### 재발방지책 #2: CORS 설정
**문제:** 브라우저에서 CORS 오류 발생  
**해결책:**
```javascript
// 서버에서 CORS 헤더 설정
app.use(cors({
    origin: ['http://localhost:3000', 'https://yourdomain.com'],
    credentials: true
}));
```

---

## 통신 문제

### 재발방지책 #3: PostMessage 통신 초기화
**문제:** Unity와 React 간 통신이 안됨  
**해결책:**
```javascript
// React에서 Unity로 메시지 전송
const sendMessageToUnity = (type, data) => {
    if (unityInstance) {
        unityInstance.SendMessage('WebCommunicationController', 'ReceiveMessageFromWeb', JSON.stringify({ type, data }));
    }
};
```

### 재발방지책 #4: Unity에서 React로 메시지 전송
**문제:** Unity에서 웹으로 메시지가 전송되지 않음  
**해결책:**
```csharp
// Unity C# 스크립트
[DllImport("__Internal")]
private static extern void SendMessageToWeb(string message);

public void SendToWeb(string type, string data)
{
    var message = JsonUtility.ToJson(new WebMessage { type = type, data = data });
    SendMessageToWeb(message);
}
```

### 재발방지책 #5: 메시지 형식 통일
**문제:** 메시지 파싱 오류 발생  
**해결책:**
```csharp
[System.Serializable]
public class WebMessage
{
    public string type;
    public string data;
}
```

### 재발방지책 #6: Unity 씬 로드 순서
**문제:** 씬 전환 시 통신이 끊어짐  
**해결책:**
```csharp
void Start()
{
    DontDestroyOnLoad(gameObject);
    StartCoroutine(WaitForSceneLoad());
}

IEnumerator WaitForSceneLoad()
{
    yield return new WaitForSeconds(1f);
    // 통신 초기화
}
```

### 재발방지책 #7: JavaScript 함수 등록 타이밍
**문제:** Unity 로드 전에 JavaScript 함수 호출  
**해결책:**
```javascript
let unityReady = false;

function onUnityReady() {
    unityReady = true;
    console.log('Unity 준비됨');
}

function sendMessageToUnity(type, data) {
    if (!unityReady) {
        console.warn('Unity가 아직 준비되지 않음');
        return;
    }
    // 메시지 전송
}
```

### 재발방지책 #8: 메모리 누수 방지
**문제:** WebGL에서 메모리 누수 발생  
**해결책:**
```csharp
[DllImport("__Internal")]
private static extern IntPtr StringToIntPtr(string str);

[DllImport("__Internal")]
private static extern void FreeIntPtr(IntPtr ptr);

public void SendMessage(string message)
{
    IntPtr ptr = StringToIntPtr(message);
    SendMessageToWeb(ptr);
    FreeIntPtr(ptr);
}
```

### 재발방지책 #9: 에러 핸들링
**문제:** 통신 오류 시 앱이 멈춤  
**해결책:**
```javascript
try {
    unityInstance.SendMessage('Controller', 'Method', data);
} catch (error) {
    console.error('Unity 통신 오류:', error);
    // 폴백 처리
}
```

### 재발방지책 #10: 타임아웃 설정
**문제:** Unity 응답 대기 중 무한 대기  
**해결책:**
```javascript
const sendMessageWithTimeout = (type, data, timeout = 5000) => {
    return new Promise((resolve, reject) => {
        const timer = setTimeout(() => {
            reject(new Error('Unity 응답 타임아웃'));
        }, timeout);
        
        // 메시지 전송 및 응답 처리
    });
};
```

### 재발방지책 #11: 메시지 큐 시스템
**문제:** Unity 로드 전 메시지 손실  
**해결책:**
```javascript
let messageQueue = [];

function queueMessage(type, data) {
    messageQueue.push({ type, data });
}

function processQueue() {
    if (unityReady && messageQueue.length > 0) {
        const message = messageQueue.shift();
        sendMessageToUnity(message.type, message.data);
    }
}
```

### 재발방지책 #12: 씬 전환 시 메시지 보존
**문제:** 씬 전환 시 통신 상태 손실  
**해결책:**
```csharp
public class PersistentController : MonoBehaviour
{
    void Awake()
    {
        DontDestroyOnLoad(gameObject);
    }
    
    void OnLevelWasLoaded(int level)
    {
        // 씬 로드 후 통신 재설정
        StartCoroutine(ReinitializeCommunication());
    }
}
```

### 재발방지책 #13: WebGL 템플릿 커스터마이징
**문제:** 기본 템플릿에서 통신 문제  
**해결책:**
- Custom WebGL Template 사용
- index.html에 통신 스크립트 추가
- Unity와 React 간 브리지 함수 구현

### 재발방지책 #14: 메시지 검증
**문제:** 잘못된 형식의 메시지로 인한 오류  
**해결책:**
```csharp
public bool ValidateMessage(string message)
{
    try {
        var webMessage = JsonUtility.FromJson<WebMessage>(message);
        return !string.IsNullOrEmpty(webMessage.type);
    } catch {
        return false;
    }
}
```

### 재발방지책 #15: 통신 상태 모니터링
**문제:** 통신 상태를 알 수 없음  
**해결책:**
```javascript
let communicationStatus = {
    unityReady: false,
    lastMessageTime: null,
    errorCount: 0
};

function updateStatus(status) {
    communicationStatus = { ...communicationStatus, ...status };
    console.log('통신 상태:', communicationStatus);
}
```

### 재발방지책 #16: 재연결 메커니즘
**문제:** 통신 끊김 시 복구 안됨  
**해결책:**
```javascript
function reconnectUnity() {
    if (unityInstance) {
        unityInstance.Quit();
    }
    
    setTimeout(() => {
        loadUnity();
    }, 1000);
}
```

### 재발방지책 #17: 메시지 우선순위
**문제:** 중요한 메시지가 지연됨  
**해결책:**
```javascript
const messagePriority = {
    HIGH: 1,
    NORMAL: 2,
    LOW: 3
};

function sendPriorityMessage(type, data, priority = messagePriority.NORMAL) {
    const message = { type, data, priority, timestamp: Date.now() };
    
    if (priority === messagePriority.HIGH) {
        messageQueue.unshift(message);
    } else {
        messageQueue.push(message);
    }
}
```

### 재발방지책 #18: 통신 로깅
**문제:** 디버깅 시 통신 내용 확인 어려움  
**해결책:**
```javascript
const communicationLogger = {
    log: (direction, type, data) => {
        console.log(`[${direction}] ${type}:`, data);
        // 로그 저장 또는 전송
    }
};
```

### 재발방지책 #19: 메시지 압축
**문제:** 큰 데이터 전송 시 성능 저하  
**해결책:**
```javascript
function compressMessage(data) {
    return LZString.compress(JSON.stringify(data));
}

function decompressMessage(compressedData) {
    return JSON.parse(LZString.decompress(compressedData));
}
```

### 재발방지책 #20: 배치 메시지 처리
**문제:** 여러 메시지를 개별적으로 처리하여 성능 저하  
**해결책:**
```javascript
let batchMessages = [];

function addToBatch(type, data) {
    batchMessages.push({ type, data });
    
    if (batchMessages.length >= BATCH_SIZE) {
        sendBatch();
    } else {
        setTimeout(sendBatch, BATCH_TIMEOUT);
    }
}

function sendBatch() {
    if (messageBatch.length > 0) {
        const batch = { type: 'batch', data: messageBatch };
        sendMessageToUnity('batch', JSON.stringify(batch));
        messageBatch = [];
    }
}
```

### 재발방지책 #21: 통신 프로토콜 버전 관리
**문제:** 버전 불일치로 인한 통신 오류  
**해결책:**
```javascript
const PROTOCOL_VERSION = '1.0.0';

function sendVersionedMessage(type, data) {
    const message = {
        version: PROTOCOL_VERSION,
        type,
        data,
        timestamp: Date.now()
    };
    sendMessageToUnity('versioned', JSON.stringify(message));
}
```

### 재발방지책 #22: 메모리 관리 함수들
**문제:** WebGL에서 메모리 누수 발생  
**해결책:**
```javascript
// PostMessage.jslib에 추가
StringToIntPtr: function(str) {
    try {
        if (!str) {
            return 0;
        }
        var length = lengthBytesUTF8(str) + 1;
        var ptr = _malloc(length);
        stringToUTF8(str, ptr, length);
        return ptr;
    } catch (error) {
        console.error('StringToIntPtr 오류:', error);
        return 0;
    }
},

FreeIntPtr: function(ptr) {
    try {
        if (ptr && ptr !== 0) {
            _free(ptr);
        }
    } catch (error) {
        console.error('FreeIntPtr 오류:', error);
    }
}
```

### 재발방지책 #23: Unity 씬 로드 완료 감지
**문제:** 씬 로드 전에 메시지 전송  
**해결책:**
```csharp
public class SceneLoadDetector : MonoBehaviour
{
    public static event Action OnSceneLoaded;
    
    void OnLevelWasLoaded(int level)
    {
        StartCoroutine(NotifySceneLoaded());
    }
    
    IEnumerator NotifySceneLoaded()
    {
        yield return new WaitForSeconds(0.5f);
        OnSceneLoaded?.Invoke();
    }
}
```

### 재발방지책 #24: JavaScript 함수 재등록
**문제:** 씬 전환 후 JavaScript 함수 호출 실패  
**해결책:**
```javascript
function ForceReinitializeJavaScriptFunctions() {
    console.log('JavaScript 함수 강제 재등록 시작');
    
    // 기존 함수 제거
    if (window.unityMessageListener) {
        window.removeEventListener('message', window.unityMessageListener);
    }
    
    // 새로운 함수 등록
    InitPostMessageListenerInternal();
    
    console.log('JavaScript 함수 강제 재등록 완료');
}
```

### 재발방지책 #25: 통신 상태 확인
**문제:** Unity 상태를 알 수 없음  
**해결책:**
```javascript
function checkUnityStatus() {
    if (typeof unityInstance === 'undefined') {
        return 'NOT_LOADED';
    }
    
    if (!unityInstance.SendMessage) {
        return 'NOT_READY';
    }
    
    return 'READY';
}
```

### 재발방지책 #26: 메시지 재시도 메커니즘
**문제:** 일시적인 통신 실패 시 메시지 손실  
**해결책:**
```javascript
function sendMessageWithRetry(type, data, maxRetries = 3) {
    let retryCount = 0;
    
    function attempt() {
        try {
            unityInstance.SendMessage('WebCommunicationController', 'ReceiveMessageFromWeb', JSON.stringify({ type, data }));
            return Promise.resolve();
        } catch (error) {
            retryCount++;
            if (retryCount < maxRetries) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        attempt().then(resolve);
                    }, 1000 * retryCount);
                });
            } else {
                return Promise.reject(error);
            }
        }
    }
    
    return attempt();
}
```

### 재발방지책 #27: 통신 초기화 순서
**문제:** 초기화 순서가 잘못되어 통신 실패  
**해결책:**
```javascript
const initializationOrder = [
    'loadUnity',
    'waitForUnityReady',
    'registerMessageHandlers',
    'sendInitialMessage'
];

async function initializeCommunication() {
    for (const step of initializationOrder) {
        await executeStep(step);
    }
}
```

### 재발방지책 #28: C# DllImport 시그니처 완전 일치 시스템
**문제:** DllImport 시그니처 불일치로 인한 오류  
**해결책:**
```csharp
// 정확한 시그니처 사용
[DllImport("__Internal")]
private static extern void SendMessageToWeb(string message);

// 잘못된 예시 (시그니처 불일치)
// [DllImport("__Internal")]
// private static extern void SendMessageToWeb(IntPtr ptr);
```

### 재발방지책 #29: 메시지 타입 검증
**문제:** 잘못된 메시지 타입으로 인한 오류  
**해결책:**
```csharp
public enum MessageType
{
    Init,
    GameStart,
    QuestionUpdate,
    ScoreUpdate,
    GameEnd
}

public bool IsValidMessageType(string type)
{
    return System.Enum.TryParse<MessageType>(type, true, out _);
}
```

### 재발방지책 #30: 통신 로그 레벨 관리
**문제:** 과도한 로그로 인한 성능 저하  
**해결책:**
```javascript
const LogLevel = {
    ERROR: 0,
    WARN: 1,
    INFO: 2,
    DEBUG: 3
};

let currentLogLevel = LogLevel.INFO;

function log(level, message, data) {
    if (level <= currentLogLevel) {
        console.log(`[${new Date().toISOString()}] ${message}`, data);
    }
}
```

### 재발방지책 #31: Unity 인스턴스 상태 관리
**문제:** Unity 인스턴스 상태 불일치  
**해결책:**
```javascript
class UnityInstanceManager {
    constructor() {
        this.instance = null;
        this.status = 'UNLOADED';
        this.listeners = [];
    }
    
    setInstance(instance) {
        this.instance = instance;
        this.status = 'LOADED';
        this.notifyListeners();
    }
    
    setStatus(status) {
        this.status = status;
        this.notifyListeners();
    }
    
    addListener(callback) {
        this.listeners.push(callback);
    }
    
    notifyListeners() {
        this.listeners.forEach(callback => callback(this.status));
    }
}
```

### 재발방지책 #32: 메시지 직렬화 최적화
**문제:** 큰 객체 직렬화로 인한 성능 저하  
**해결책:**
```csharp
[System.Serializable]
public class OptimizedMessage
{
    public string t; // type
    public string d; // data
    public long ts;  // timestamp
    
    public OptimizedMessage(string type, string data)
    {
        t = type;
        d = data;
        ts = DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
    }
}
```

### 재발방지책 #33: 통신 오류 복구
**문제:** 통신 오류 후 복구 안됨  
**해결책:**
```javascript
class CommunicationRecovery {
    constructor() {
        this.errorCount = 0;
        this.maxErrors = 5;
        this.recoveryDelay = 1000;
    }
    
    handleError(error) {
        this.errorCount++;
        console.error('통신 오류:', error);
        
        if (this.errorCount >= this.maxErrors) {
            this.attemptRecovery();
        }
    }
    
    attemptRecovery() {
        console.log('통신 복구 시도 중...');
        // 복구 로직
        setTimeout(() => {
            this.resetErrorCount();
        }, this.recoveryDelay);
    }
    
    resetErrorCount() {
        this.errorCount = 0;
    }
}
```

### 재발방지책 #34: 메시지 우선순위 큐
**문제:** 중요한 메시지가 지연됨  
**해결책:**
```javascript
class PriorityQueue {
    constructor() {
        this.highPriority = [];
        this.normalPriority = [];
        this.lowPriority = [];
    }
    
    enqueue(message, priority = 'normal') {
        switch (priority) {
            case 'high':
                this.highPriority.push(message);
                break;
            case 'normal':
                this.normalPriority.push(message);
                break;
            case 'low':
                this.lowPriority.push(message);
                break;
        }
    }
    
    dequeue() {
        if (this.highPriority.length > 0) {
            return this.highPriority.shift();
        }
        if (this.normalPriority.length > 0) {
            return this.normalPriority.shift();
        }
        if (this.lowPriority.length > 0) {
            return this.lowPriority.shift();
        }
        return null;
    }
}
```

### 재발방지책 #35: 실패 시 재시도
**문제:** 일시적인 통신 실패 시 메시지 손실  
**해결책:**
```javascript
function sendMessageWithRetry(type, data, maxRetries = 3) {
    let retryCount = 0;
    
    function attempt() {
        try {
            unityInstance.SendMessage('WebCommunicationController', 'ReceiveMessageFromWeb', JSON.stringify({ type, data }));
            return Promise.resolve();
        } catch (error) {
            retryCount++;
            if (retryCount < maxRetries) {
                return new Promise(resolve => {
                    setTimeout(() => {
                        attempt().then(resolve);
                    }, 1000 * retryCount);
                });
            } else {
                return Promise.reject(error);
            }
        }
    }
    
    return attempt();
}
```

### 재발방지책 #36: 통신 상태 모니터링
**문제:** 통신 상태를 실시간으로 모니터링할 수 없음  
**해결책:**
```javascript
class CommunicationMonitor {
    constructor() {
        this.status = 'disconnected';
        this.lastMessageTime = null;
        this.messageCount = 0;
        this.errorCount = 0;
    }
    
    updateStatus(newStatus) {
        this.status = newStatus;
        this.notifyStatusChange();
    }
    
    recordMessage() {
        this.messageCount++;
        this.lastMessageTime = Date.now();
    }
    
    recordError() {
        this.errorCount++;
    }
    
    getStats() {
        return {
            status: this.status,
            messageCount: this.messageCount,
            errorCount: this.errorCount,
            lastMessageTime: this.lastMessageTime
        };
    }
}
```

### 재발방지책 #37: InitPostMessageListenerInternal에 개선사항 적용
**문제:** 메시지 리스너 초기화 문제  
**해결책:**
```javascript
InitPostMessageListenerInternal: function(ptr) {
    console.log('=== 재발방지책 #37: InitPostMessageListenerInternal 호출됨 ===');
    try {
        // 기존 리스너 제거 (중복 방지)
        if (window.unityMessageListener) {
            window.removeEventListener('message', window.unityMessageListener);
        }
        
        // 새로운 리스너 생성
        window.unityMessageListener = function(e) {
            // 메시지 처리 로직
        };
        
        // 리스너 등록
        window.addEventListener('message', window.unityMessageListener);
        console.log('메시지 리스너 등록 완료');
    } catch (error) {
        console.error('InitPostMessageListenerInternal 오류:', error);
    }
}
```

### 재발방지책 #38: 씬 전환 시 JavaScript 함수 재등록
**문제:** 씬 전환 후 JavaScript 함수 호출 실패  
**해결책:**
```javascript
function ForceReinitializeJavaScriptFunctions() {
    console.log('JavaScript 함수 강제 재등록 시작');
    
    // 기존 함수 제거
    if (window.unityMessageListener) {
        window.removeEventListener('message', window.unityMessageListener);
    }
    
    // 새로운 함수 등록
    InitPostMessageListenerInternal();
    
    console.log('JavaScript 함수 강제 재등록 완료');
}
```

### 재발방지책 #39: Unity-React 초기화 무한 루프 방지
**문제:** Unity와 React 간 초기화 메시지가 무한 루프 발생  
**원인:** 
- Unity에서 `init-complete` 메시지를 보내지 않아서 React가 계속 초기화 메시지 전송
- React에서 초기화 완료 상태를 제대로 추적하지 못함

**해결책:**
1. **React 측 수정 (UnityGamePage.tsx):**
```typescript
const [initializationComplete, setInitializationComplete] = useState(false);
const [initAttempts, setInitAttempts] = useState(0);

const sendInitMessage = () => {
    if (!gameState || initSent || initializationComplete || initAttempts >= 3) {
        return;
    }
    
    const initData = {
        role: gameState.role,
        code: gameState.code,
        nickname: gameState.nickname,
        gameId: gameState.gameId
    };
    
    sendMessageToUnity('init', JSON.stringify(initData));
    setInitSent(true);
    setInitAttempts(prev => prev + 1);
};

const handleUnityMessage = (message: UnityMessage) => {
    switch (message.type) {
        case 'unity-loaded':
            setUnityLoaded(true);
            // unity-loaded에서는 초기화 메시지를 보내지 않음 (무한 루프 방지)
            break;
        case 'unity-ready':
            if (!initSent && !initializationComplete) {
                sendInitMessage();
            }
            break;
        case 'init-complete':
            setInitializationComplete(true);
            setInitSent(false);
            break;
    }
};
```

2. **Unity 측 수정 (WebCommunicationController.cs):**
```csharp
private void HandleInit(string data)
{
    try {
        InitData initData = JsonUtility.FromJson<InitData>(data);
        GameStateManager.InitializeGame(initData);
        
        // 초기화 완료 메시지 전송
        StartCoroutine(SendInitCompleteDelayed());
    } catch (Exception e) {
        Debug.LogError($"Init 처리 오류: {e.Message}");
    }
}

private IEnumerator SendInitCompleteDelayed()
{
    yield return new WaitForSeconds(0.5f);
    SendMessageToWeb("init-complete", "");
}
```

3. **데이터 구조 추가 (GameData.cs):**
```csharp
[System.Serializable]
public class InitData
{
    public string role;
    public string code;
    public string nickname;
    public string gameId;
}
```

### 재발방지책 #40: Unity 객체 찾기 실패 및 폴백 메커니즘
**문제:** `SendMessage: object WebCommunicationController not found!` 오류 발생  
**원인:** 
- Unity 씬에서 `WebCommunicationController` 객체가 존재하지 않음
- 씬 전환 시 객체가 파괴됨
- `DontDestroyOnLoad` 설정이 누락됨

**해결책:**
1. **PostMessage.jslib 폴백 메커니즘 강화:**
```javascript
// init 메시지 처리 시 폴백 로직
if (e.data.type === 'init') {
    try {
        target.SendMessage('WebCommunicationController', 'ReceiveMessageFromWeb', fullMessage);
        console.log('Unity에 init 메시지 전달 성공 (WebCommunicationController)');
    } catch (error) {
        console.warn('WebCommunicationController not found, trying SocketManager fallback');
        try {
            target.SendMessage('SocketManager', 'OnBrowserMessage', fullMessage);
            console.log('Unity에 init 메시지 전달 성공 (SocketManager 폴백)');
        } catch (fallbackError) {
            console.error('Both WebCommunicationController and SocketManager not found:', fallbackError);
            console.warn('모든 Unity 컨트롤러를 찾을 수 없습니다. 씬을 다시 로드하거나 컨트롤러를 확인하세요.');
        }
    }
}
```

2. **Unity 씬 설정 확인사항:**
   - `WebCommunicationController` 스크립트가 씬에 있는 GameObject에 연결되어 있는지 확인
   - `DontDestroyOnLoad` 설정 확인
   - 씬 전환 시에도 객체가 유지되는지 확인

3. **자동 생성 스크립트 추가 (AutoWebCommunicationController.cs):**
```csharp
public class AutoWebCommunicationController : MonoBehaviour
{
    void Awake()
    {
        if (FindObjectOfType<WebCommunicationController>() == null)
        {
            GameObject controllerObj = new GameObject("WebCommunicationController");
            controllerObj.AddComponent<WebCommunicationController>();
            DontDestroyOnLoad(controllerObj);
        }
    }
}
```

### 재발방지책 #41: Unity 씬 설정 및 컨트롤러 자동 생성
**문제:** Unity 씬에서 필수 컨트롤러가 없어서 통신 실패  
**원인:**
- Unity 씬에서 `WebCommunicationController`가 수동으로 추가되지 않음
- 씬 전환 시 컨트롤러가 파괴됨
- 프리팹 설정이 누락됨

**해결책:**
1. **Unity 씬 설정:**
   - BootScene에 `AutoWebCommunicationController` 스크립트 추가
   - 또는 `WebCommunicationController` 프리팹을 씬에 배치
   - `DontDestroyOnLoad` 설정 확인

2. **프리팹 생성:**
   - `WebCommunicationController.prefab` 생성
   - Resources 폴더에 배치하여 런타임 로드 가능하게 설정

3. **자동 초기화 스크립트:**
```csharp
public class WebCommunicationInitializer : MonoBehaviour
{
    void Start()
    {
        if (FindObjectOfType<WebCommunicationController>() == null)
        {
            // 프리팹에서 로드하거나 동적으로 생성
            GameObject prefab = Resources.Load<GameObject>("WebCommunicationController");
            if (prefab != null)
            {
                Instantiate(prefab);
            }
            else
            {
                GameObject obj = new GameObject("WebCommunicationController");
                obj.AddComponent<WebCommunicationController>();
                DontDestroyOnLoad(obj);
            }
        }
    }
}
```

4. **Unity 씬 체크리스트:**
   - [ ] BootScene에 `WebCommunicationInitializer` 또는 `AutoWebCommunicationController` 추가
   - [ ] `WebCommunicationController`가 `DontDestroyOnLoad` 설정됨
   - [ ] 씬 전환 시에도 컨트롤러가 유지되는지 확인
   - [ ] 프리팹 참조가 올바르게 설정됨

---

## 성능 문제

### 재발방지책 #42: 메시지 배치 처리
**문제:** 개별 메시지 처리로 인한 성능 저하  
**해결책:**
```javascript
let messageBatch = [];
const BATCH_SIZE = 10;
const BATCH_TIMEOUT = 100;

function addToBatch(type, data) {
    messageBatch.push({ type, data });
    
    if (messageBatch.length >= BATCH_SIZE) {
        sendBatch();
    } else {
        setTimeout(sendBatch, BATCH_TIMEOUT);
    }
}

function sendBatch() {
    if (messageBatch.length > 0) {
        const batch = { type: 'batch', data: messageBatch };
        sendMessageToUnity('batch', JSON.stringify(batch));
        messageBatch = [];
    }
}
```

---

## 디버깅

### 재발방지책 #43: 통신 로그 시스템
**문제:** 디버깅 시 통신 내용 확인 어려움  
**해결책:**
```javascript
class CommunicationLogger {
    constructor() {
        this.logs = [];
        this.maxLogs = 1000;
    }
    
    log(direction, type, data) {
        const logEntry = {
            timestamp: Date.now(),
            direction,
            type,
            data,
            stack: new Error().stack
        };
        
        this.logs.push(logEntry);
        
        if (this.logs.length > this.maxLogs) {
            this.logs.shift();
        }
        
        console.log(`[${direction}] ${type}:`, data);
    }
    
    getLogs() {
        return this.logs;
    }
    
    clearLogs() {
        this.logs = [];
    }
}
```

---

## 최신 문제 해결

### 재발방지책 #69: WebGL DllImport-jslib 시그니처 완전 일치
문제: RuntimeError: null function or function signature mismatch 재발
- C# DllImport는 IntPtr 기반으로 선언 (문자열은 C 문자열 포인터로 전달)
- jslib 함수 시그니처(인자 개수/순서/타입)가 정확히 일치해야 함
- 씬 전환 후 `NotifySceneTransitionCompleteInternal`로 React에 알림, React는 단일 초기화 메시지 재전송 허용

코드 원칙:
- C#: `[DllImport("__Internal")] private static extern void FnName(IntPtr arg1, ...);`
- JSlib: `FnName: function(arg1) { var s = UTF8ToString(arg1); ... }`

### 재발방지책 #70: 문자열 포인터 관리 일원화
문제: 빈 문자열/널 처리로 포인터 불일치
- 모든 포인터는 C#에서만 관리
- `CStringAllocator.StringToIntPtr(string)`, `CStringAllocator.FreeIntPtr(IntPtr)` 사용
- 빈 문자열도 NUL-terminated C-string으로 전달(포인터 0 금지)

### 재발방지책 #75: 초기화 메시지 재전송 타이밍 통합
문제: 중복 전송/타이밍 경합으로 통신 손실
- Unity iframe load, `unity-loaded`, `sceneTransitionComplete`에서 한 번만 init 전송
- 필요 시 force 재전송 허용하되 ref 플래그로 중복 차단

### 재발방지책 #76: 정적 자산 서빙 보장 (SPA 우회)
문제: `/unity/index.html`가 SPA fallback으로 404
- Vite dev 서버에 `/unity` 경로를 `public/unity`에서 직접 서빙하는 미들웨어 추가
- 강력 새로고침 전 캐시 비활성화(DevTools Disable cache)

### 배포/동기화 체크리스트(필수 게이트)
1) Unity WebGL 클린 빌드
- Compression Disabled, Exceptions Full, Managed Stripping Level Disabled
2) 산출물 동기화
- `client/public/unity/index.html` + `client/public/unity/Build/` 4종(`unity.loader.js`, `unity.framework.js`, `unity.data`, `unity.wasm`) 동시 교체
3) 서버/캐시
- dev 서버는 반드시 `project/client`에서 실행, 서버 재시작 후 강력 새로고침
4) 네트워크 검증
- Network 탭에서 위 4종이 200 OK이며, 응답이 JS/wasm/data인지 확인(HTML이면 경로/라우터 문제)
5) 시그니처 일치 검증
- C# DllImport(IntPtr) ↔ jslib 함수 정의(UTF8ToString 변환) 일치
6) 통신 이벤트 순서
- `sceneTransitionComplete` 수신 → 500ms 지연 후 init(force) 1회 전송 → 중복 차단

### 운영 중 재발 대응 Runbook
- “null function…” 발생 시
  1) 최신 WebGL 빌드로 산출물 전체 동기화
  2) 캐시 비활성화 후 강력 새로고침
  3) C#/jslib 시그니처 재확인(IntPtr 일치)
- “/unity/index.html 404” 발생 시
  1) dev 서버가 `project/client`에서 실행 중인지 확인
  2) Vite 미들웨어 적용 여부 확인(서버 재시작 필요)
  3) `client/public/unity/index.html` 존재/시간 갱신 확인

### 재발방지책 #42: Unity API 호환성 문제 해결 (FindObjectsOfType → FindObjectsByType → FindFirstObjectByType)
**문제:** Unity 6.0.1에서 `FindObjectsOfType<T>()`가 deprecated되어 경고 발생  
**원인:** 
- Unity 6.0.1에서 `FindObjectsOfType<T>()`가 deprecated됨
- `FindObjectsByType<T>(FindObjectSortMode.None)` 사용 시 `FindObjectSortMode`를 찾을 수 없음
- `FindObjectOfType<T>()`도 deprecated되어 `FindFirstObjectByType<T>()` 사용 권장

**해결책:**
1. **단일 객체가 필요한 경우 `FindFirstObjectByType<T>()` 사용:**
```csharp
// 변경 전 (deprecated)
var controller = FindObjectOfType<WebCommunicationController>();

// 변경 후 (권장)
var controller = FindFirstObjectByType<WebCommunicationController>();
```

2. **배열이 필요한 경우 `FindObjectsByType<T>(FindObjectsSortMode.None)` 사용:**
```csharp
// 변경 전 (deprecated)
var controllers = FindObjectsOfType<WebCommunicationController>();

// 변경 후 (권장)
var controllers = FindObjectsByType<WebCommunicationController>(FindObjectsSortMode.None);
```

3. **적용된 파일 목록:**
   - `UnityMegaInitializer.cs`
   - `UnityStartupInitializer.cs`
   - `UnitySuperInitializer.cs`
   - `UnityUltimateInitializer.cs`
   - `UnityFinalInitializer.cs`
   - `UnityMasterInitializer.cs`
   - `UnityBootstrap.cs`
   - `AutoInitializer.cs`
   - `SceneInitializer.cs`
   - `WebCommunicationInitializer.cs`
   - `AutoWebCommunicationController.cs`
   - `FontSetupUtility.cs`
   - `KoreanFontSetup.cs`

4. **변경 사항 요약:**
   - 단일 객체 검색: `FindObjectOfType<T>()` → `FindFirstObjectByType<T>()`
   - 배열 검색: `FindObjectsOfType<T>()` → `FindObjectsByType<T>(FindObjectsSortMode.None)`
   - `#pragma warning disable CS0618` 및 `#pragma warning restore CS0618` 제거 (더 이상 필요 없음)

**현재 상태:** ✅ 모든 파일 수정 완료. Unity API 호환성 문제 해결됨.

**추가 수정 사항 (2024년 1월):**
- `KoreanFontSetup.cs`: 배열 반환 메서드로 수정하여 모든 텍스트 컴포넌트에 폰트 적용
- `FontSetupUtility.cs`: `FindObjectsByType`에 `FindObjectsSortMode.None` 인수 추가

### 재발방지책 #43: Unity API 버전 호환성 관리
**문제:** Unity 버전별 API 차이로 인한 컴파일 오류  
**해결책:**
```csharp
// Unity 버전별 API 호환성 처리
#if UNITY_2022_3_OR_NEWER
    // Unity 2022.3 이상에서 사용 가능한 새로운 API
    var controller = FindFirstObjectByType<WebCommunicationController>();
#else
    // 이전 버전에서 사용하는 API
    var controller = FindObjectOfType<WebCommunicationController>();
#endif
```

### 재발방지책 #44: Unity API 변경 대응 체계
**문제:** Unity 버전 업데이트 시 API 변경으로 인한 오류  
**해결책:**
1. **정기적인 API 호환성 검사:**
   - Unity 릴리즈 노트 확인
   - Deprecated API 경고 모니터링
   - 자동화된 빌드에서 경고 검출

2. **API 변경 대응 프로세스:**
   ```bash
   # 1. 경고 검출
   grep -r "warning CS0618" Assets/
   
   # 2. 변경된 API 확인
   grep -r "FindObjectOfType\|FindObjectsOfType" Assets/
   
   # 3. 새로운 API로 일괄 변경
   # 4. 테스트 수행
   # 5. 재발방지책 가이드 업데이트
   ```

3. **API 변경 히스토리 관리:**
   - Unity 버전별 API 변경 사항 문서화
   - 마이그레이션 가이드 작성
   - 자동화된 스크립트 개발

### 재발방지책 #45: Unity-React 게임 시작 메시지 전송 타이밍
**문제:** `init-complete` 메시지 수신 후 Unity가 "역할 정보 수신 대기 중..." 상태에서 멈춤  
**원인:** 
- Unity 초기화 완료 후 `gameStart` 메시지를 기다리지만 React에서 전송하지 않음
- `socket.on('gameStarted')` 이벤트에만 의존하여 즉시 게임 시작이 안됨

**해결책:**
1. **React에서 `init-complete` 수신 후 즉시 `gameStart` 메시지 전송:**
```javascript
case 'init-complete':
  console.log('Unity 초기화 완료');
  setInitializationComplete(true);
  setInitSent(false);
  
  // 초기화 완료 후 즉시 게임 시작 메시지 전송
  if (gameState) {
    console.log('게임 시작 메시지 전송');
    const gameStartData = {
      gameCode: gameState.gameCode,
      playerName: gameState.playerName || 'Unknown',
      isTeacher: gameState.mode === 'teacher',
      characterId: gameState.characterId || '',
      gameConfig: {
        gameMode: 'time',
        timeLimit: 5,
        scoreLimit: 100
      }
    };
    sendToUnity('gameStart', gameStartData);
  }
  break;
```

2. **데이터 구조 일치 확인:**
   - `GameStartData` 클래스의 필드와 전송하는 데이터 구조 일치
   - `gameId` 필드 제거하고 `gameConfig` 객체 사용

3. **적용된 파일:**
   - `client/src/pages/UnityGamePage.tsx`

### 재발방지책 #46: 씬 전환 시 무한루프 방지 시스템
**문제:** 씬 언로드/로드 반복으로 인한 무한루프 발생  
**원인:** 씬 전환 시 싱글톤 객체들이 제대로 유지되지 않고, 씬이 계속 재로드됨  
**해결책:** `SceneTransitionManager` 생성 및 강화된 싱글톤 체크
```csharp
// SceneTransitionManager.cs
[DefaultExecutionOrder(-10000)]
public class SceneTransitionManager : MonoBehaviour
{
    private bool isTransitioning = false;
    private string lastLoadedScene = "";
    private int transitionCount = 0;
    private const int MAX_TRANSITIONS = 5;
    
    private void OnSceneUnloaded(Scene scene)
    {
        if (scene.name == lastLoadedScene)
        {
            transitionCount++;
            if (transitionCount >= MAX_TRANSITIONS)
            {
                Debug.LogError("무한루프 감지! 씬 전환을 중단합니다");
                StopAllCoroutines();
                isTransitioning = false;
                transitionCount = 0;
                return;
            }
        }
    }
}
```

### 재발방지책 #47: 강화된 싱글톤 패턴 구현
**문제:** 씬 전환 시 싱글톤 객체 중복 생성 및 "이미 존재합니다" 메시지  
**원인:** 기존 싱글톤 체크가 씬 전환 시 충분하지 않음  
**해결책:** 모든 핵심 컨트롤러에 강화된 싱글톤 체크 및 씬 전환 이벤트 구독
```csharp
void Awake()
{
    if (Instance == null)
    {
        Instance = this;
        DontDestroyOnLoad(gameObject);
        
        // 씬 전환 이벤트 구독
        SceneManager.sceneUnloaded += OnSceneUnloaded;
        SceneManager.sceneLoaded += OnSceneLoaded;
    }
    else if (Instance != this)
    {
        Destroy(gameObject);
        return;
    }
}
```

### 재발방지책 #48: 씬 전환 중 초기화 처리 지연
**문제:** 씬 전환 중 초기화 처리로 인한 무한루프  
**원인:** 씬이 전환되는 동안 초기화 처리가 계속 실행되어 상태 불일치 발생  
**해결책:** 모든 초기화 메서드에서 씬 전환 상태 확인 후 지연 처리
```csharp
private void HandleInit(string data)
{
    // 씬 전환 매니저 상태 확인
    if (SceneTransitionManager.Instance != null && SceneTransitionManager.Instance.IsTransitioning())
    {
        StartCoroutine(DelayedHandleInit(data));
        return;
    }
    
    // 정상적인 초기화 처리
}

private IEnumerator DelayedHandleInit(string data)
{
    while (SceneTransitionManager.Instance != null && SceneTransitionManager.Instance.IsTransitioning())
    {
        yield return new WaitForSeconds(0.1f);
    }
    
    // 씬 전환 완료 후 초기화 처리 재시도
    HandleInit(data);
}
```

### 재발방지책 #49: 서버 포트 충돌 문제 해결
**문제:** `Error: listen EADDRINUSE: address already in use :::8080` 오류 발생  
**원인:** 이전 서버 프로세스가 완전히 종료되지 않아 포트 8080이 이미 사용 중  
**해결책:** 포트 사용 중인 프로세스 확인 및 강제 종료
```bash
# Windows에서 포트 사용 중인 프로세스 확인
netstat -ano | findstr :8080

# 프로세스 ID로 강제 종료
taskkill /PID [프로세스ID] /F

# 또는 모든 Node.js 프로세스 종료 (주의: 다른 Node.js 앱도 종료됨)
taskkill /IM node.exe /F
```

**수동 해결 방법:**
```bash
# Windows에서 포트 사용 중인 프로세스 확인
netstat -ano | findstr :8080

# 프로세스 ID로 강제 종료
taskkill /PID [프로세스ID] /F

# 또는 모든 Node.js 프로세스 종료 (주의: 다른 Node.js 앱도 종료됨)
taskkill /IM node.exe /F
```

### 재발방지책 #50: 게임 시작 메시지 처리 시 역할 정보 업데이트
**문제:** `gameStart` 메시지 수신 후에도 "역할 정보 수신 대기 중..." 상태로 계속 대기  
**원인:** `BootLoader`가 `SocketManager.Instance.CurrentRole`을 확인하는데, `HandleGameStart`에서 이 값을 업데이트하지 않음  
**해결책:** `HandleGameStart`에서 `CurrentRole` 업데이트
```csharp
private void HandleGameStart(string data)
{
    try
    {
        currentGameData = JsonUtility.FromJson<GameStartData>(data);
        isGameStarted = true;
        isTeacher = currentGameData.isTeacher;
        
        // CurrentRole 업데이트 (BootLoader 대기 해제용)
        CurrentRole = currentGameData.isTeacher ? "teacher" : "student";
        
        // ... 나머지 처리
    }
    catch (Exception e)
    {
        Debug.LogError($"게임 시작 처리 오류: {e.Message}");
    }
}
```

### 재발방지책 #51: 한글 폰트 경고 해결
**문제:** `The character with Unicode value \uCE90 was not found in the [LiberationSans SDF] font asset` 경고 발생  
**원인:** 기본 폰트가 한글 문자를 지원하지 않음  
**해결책:** `KoreanFontSetup` 스크립트로 한글 폰트 자동 적용
```csharp
[DefaultExecutionOrder(-9999)]
public class KoreanFontSetup : MonoBehaviour
{
    public TMP_FontAsset koreanFontAsset;
    
    void SetupKoreanFonts()
    {
        // 한글 폰트 찾기 및 적용
        koreanFontAsset = Resources.Load<TMP_FontAsset>("Fonts/NotoSansKR-Regular SDF");
        
        if (koreanFontAsset != null)
        {
            // 모든 TextMeshPro 컴포넌트에 한글 폰트 적용
            ApplyKoreanFontToAllTexts();
        }
    }
    
    public void ApplyKoreanFontToAllTexts()
    {
        TextMeshProUGUI[] textComponents = FindObjectsOfType<TextMeshProUGUI>();
        foreach (var text in textComponents)
        {
            text.font = koreanFontAsset;
        }
    }
}
```

### 재발방지책 #52: 역할 정보 설정 타이밍 문제 해결
**문제:** React에서 `role: 'teacher'`로 접속했는데도 Unity에서 "student" 역할로 인식되어 `StudentLobbyScene`으로 이동  
**원인:** `SocketManager.HandleInit`에서 `CurrentRole`을 설정했지만, `BootLoader`가 이를 제대로 인식하지 못함. 타이밍 문제로 `HandleInit` 호출 전에 `BootLoader`가 이미 `WaitForRoleInformation`을 시작했고, 시간 초과 후 `SetDefaultRole("student")`가 호출됨  
**해결책:** `HandleInit`에서 `CurrentRole` 설정 후 즉시 `BootLoader`에 알림
```csharp
// SocketManager.HandleInit에서
CurrentRole = initData["role"];
CurrentCode = initData["code"];
CurrentNickname = initData["nickname"];
isTeacher = CurrentRole == "teacher";

// BootLoader에 즉시 알림
if (BootLoader.Instance != null)
{
    BootLoader.Instance.SetRoleReceived(true);
    BootLoader.Instance.OnRoleSet();
    Debug.Log($"BootLoader에 역할 설정 알림 전송됨 - 역할: {CurrentRole}");
}
```

**추가 디버깅:**
```csharp
// BootLoader.WaitForRoleInformation에서 주기적으로 상태 확인
if (waitTime % 5f < 0.1f)
{
    Debug.Log($"역할 정보 수신 대기 중... ({waitTime:F1}초 경과)");
    if (SocketManager.Instance != null)
    {
        Debug.Log($"현재 SocketManager.CurrentRole: '{SocketManager.Instance.CurrentRole}'");
    }
}

// BootLoader.LoadSceneBasedOnRole에서 상세 정보 출력
Debug.Log($"=== 씬 로드 결정 ===");
Debug.Log($"SocketManager.Instance.CurrentRole: '{role}'");
Debug.Log($"SocketManager.Instance.IsTeacher(): {SocketManager.Instance.IsTeacher()}");
Debug.Log($"roleReceived 플래그: {roleReceived}");
```

### 재발방지책 #53: C# 문자열 보간 조건부 표현식 문법 오류 해결
**문제:** `WebCommunicationController.cs`에서 문자열 보간 내 조건부 표현식 사용 시 컴파일 오류 발생  
**오류 메시지:**
- `CS8076: Missing close delimiter '}' for interpolated expression started with '{'`
- `CS8361: A conditional expression cannot be used directly in a string interpolation because the ':' ends the interpolation. Parenthesize the conditional expression.`
- `CS1003: Syntax error, ',' expected`

**원인:** C#에서 문자열 보간(`$"..."`) 내에서 조건부 표현식(삼항 연산자)을 사용할 때 괄호로 감싸지 않으면 컴파일러가 보간 구문과 혼동함

**해결책:** 조건부 표현식을 괄호로 감싸기
```csharp
// 변경 전 (오류 발생)
Debug.Log($"게임 시작: {currentGameData.gameCode}, 플레이어: {currentGameData.playerName}, 역할: {currentGameData.isTeacher ? "teacher" : "student"}");

// 변경 후 (정상 작동)
Debug.Log($"게임 시작: {currentGameData.gameCode}, 플레이어: {currentGameData.playerName}, 역할: {(currentGameData.isTeacher ? "teacher" : "student")}");
```

**적용된 파일:**
- `Assets/Scripts/Controllers/WebCommunicationController.cs` (라인 289)

**재발 방지 방법:**
1. 문자열 보간 내에서 조건부 표현식 사용 시 항상 괄호로 감싸기
2. 복잡한 표현식은 별도 변수로 분리 후 보간에 사용
3. 코드 리뷰 시 문자열 보간 구문 검토 필수

### 재발방지책 #54: 웹사이트 코드 통신 안정성 개선
**문제:** Unity-React 통신에서 메시지 전송 실패 및 연결 불안정  
**원인:** 
- Unity Bridge에서 예외 처리 부족
- Socket.IO 연결 상태 확인 부족
- 메시지 큐 처리 시 타임아웃 없음

**해결책:**
1. **Unity Bridge 예외 처리 강화:**
```typescript
// unityBridge.ts
sendToUnity(type: string, data: any) {
  const message: UnityMessage = { type, data };

  if (!this.isUnityReady) {
    this.messageQueue.push(message);
    return;
  }

  try {
    if (this.unityInstance && this.unityInstance.SendMessage) {
      this.unityInstance.SendMessage('GameManager', 'ReceiveWebMessage', JSON.stringify(message));
    } else {
      console.warn('Unity 인스턴스가 준비되지 않았습니다.');
    }
  } catch (error) {
    console.error('Unity 메시지 전송 실패:', error);
    // 재시도 로직 추가
    this.retryMessage(message);
  }
}
```

2. **Socket.IO 연결 상태 모니터링:**
```typescript
// socket.ts
export const initSocket = (token?: string) => {
  if (socket) socket.disconnect();
  
  socket = io(SOCKET_URL, {
    auth: { token },
    transports: ['websocket', 'polling'],
    autoConnect: true,
    timeout: 5000,
    reconnection: true,
    reconnectionAttempts: 5,
    reconnectionDelay: 1000
  });
  
  socket.on('connect', () => {
    console.log('Socket connected:', socket?.id);
  });
  
  socket.on('connect_error', (error) => {
    console.error('Socket connection error:', error);
    // 재연결 시도
    setTimeout(() => {
      if (socket) socket.connect();
    }, 2000);
  });
  
  socket.on('disconnect', (reason) => {
    console.log('Socket disconnected:', reason);
    if (reason === 'io server disconnect') {
      // 서버에서 연결을 끊은 경우 재연결
      socket.connect();
    }
  });
  
  return socket;
};
```

3. **메시지 큐 타임아웃 처리:**
```typescript
// unityBridge.ts
private processMessageQueue() {
  if (!this.isUnityReady) return;

  const maxRetries = 3;
  let retryCount = 0;

  while (this.messageQueue.length > 0 && retryCount < maxRetries) {
    const message = this.messageQueue.shift();
    if (message) {
      try {
        this.sendToUnity(message.type, message.data);
      } catch (error) {
        console.error('메시지 전송 실패, 재시도:', retryCount + 1);
        retryCount++;
        this.messageQueue.unshift(message); // 큐 앞에 다시 추가
      }
    }
  }
}
```

**재발방지책:**
1. 모든 Unity 통신에 try-catch 블록 추가
2. Socket.IO 연결 상태 지속적 모니터링
3. 메시지 전송 실패 시 재시도 로직 구현
4. 정기적인 연결 상태 확인 및 로그 기록
5. 사용자에게 연결 상태 피드백 제공

**영향받는 파일:**
- `project/client/src/utils/unityBridge.ts`
- `project/client/src/socket/socket.ts`

### 재발방지책 #55: Unity API 타입 변환 오류 해결
**문제:** Unity API 호환성 수정 과정에서 발생한 타입 변환 및 메서드 오버로드 오류  
**오류 메시지:**
```
Assets\Scripts\Utils\KoreanFontSetup.cs(91,44): error CS0029: Cannot implicitly convert type 'TMPro.TextMeshProUGUI' to 'TMPro.TextMeshProUGUI[]'
Assets\Scripts\Utils\KoreanFontSetup.cs(92,44): error CS0029: Cannot implicitly convert type 'TMPro.TextMeshPro' to 'TMPro.TextMeshPro[]'
Assets\Scripts\Utils\KoreanFontSetup.cs(96,28): error CS1061: 'TextMeshProUGUI[]' does not contain a definition for 'font'
Assets\Scripts\Utils\FontSetupUtility.cs(72,40): error CS1501: No overload for method 'FindObjectsByType' takes 0 arguments
```

**원인:**
- `FindFirstObjectByType<T>()`는 단일 객체를 반환하지만 코드에서는 배열을 기대함
- `FindObjectsByType<T>()`는 `FindObjectsSortMode` 인수가 필요함
- 배열 처리 로직이 단일 객체 처리로 잘못 변경됨

**해결책:**
1. **배열이 필요한 경우 `FindObjectsByType<T>(FindObjectsSortMode.None)` 사용:**
```csharp
// 변경 전 (오류)
TextMeshProUGUI[] textComponents = FindFirstObjectByType<TextMeshProUGUI>();

// 변경 후 (올바름)
TextMeshProUGUI[] textComponents = FindObjectsByType<TextMeshProUGUI>(FindObjectsSortMode.None);
```

2. **배열 순회 로직 복원:**
```csharp
// 변경 전 (오류)
if (textComponents != null)
{
    textComponents.font = koreanFontAsset; // 배열에 직접 접근
}

// 변경 후 (올바름)
foreach (var text in textComponents)
{
    if (text.font != koreanFontAsset)
    {
        text.font = koreanFontAsset;
        appliedCount++;
    }
}
```

3. **적용된 파일:**
   - `Assets/Scripts/Utils/KoreanFontSetup.cs`
   - `Assets/Scripts/Utils/FontSetupUtility.cs`

**재발방지책:**
1. Unity API 변경 시 반환 타입 확인 필수
2. 단일 객체 vs 배열 반환 메서드 구분
3. `FindObjectsByType` 사용 시 `FindObjectsSortMode` 인수 필수
4. 배열 처리 로직 유지 (foreach 루프)
5. 컴파일 오류 발생 시 즉시 수정 및 테스트

**현재 상태:** ✅ 모든 타입 변환 오류 해결됨.

### 현재 발생 중인 문제: 역할 정보 설정 타이밍 문제
**상태:** 해결됨 (재발방지책 #52 적용)  
**문제:** React에서 `role: 'teacher'`로 접속했는데도 Unity에서 "student" 역할로 인식되어 `StudentLobbyScene`으로 이동  
**최종 해결책:**
1. `SocketManager.HandleInit`에서 `CurrentRole` 설정 후 즉시 `BootLoader.SetRoleReceived(true)` 호출
2. `BootLoader.WaitForRoleInformation`에서 주기적으로 `SocketManager.CurrentRole` 상태 확인
3. `BootLoader.LoadSceneBasedOnRole`에서 상세한 디버그 정보 출력
4. 타이밍 문제로 인한 역할 정보 누락 방지

### 이전 문제: 씬 전환 무한루프
**상태:** 해결됨 (재발방지책 #46, #47, #48, #50 적용)  
**최종 해결책:**
1. `SceneTransitionManager`로 씬 전환 모니터링
2. 강화된 싱글톤 패턴으로 중복 생성 방지
3. 씬 전환 중 초기화 처리 지연
4. 무한루프 감지 및 강제 중단
5. `gameStart` 메시지 처리 시 `CurrentRole` 업데이트

### 다음 단계:
1. Unity 씬에서 `SceneTransitionManager` 스크립트 추가
2. 모든 핵심 컨트롤러에 강화된 싱글톤 체크 적용
3. `KoreanFontSetup` 스크립트로 한글 폰트 설정
4. 씬 전환 테스트 수행

---

## 재발방지책 #56: 역할 정보 설정 타이밍 문제 해결 및 씬 전환 무한루프 방지

**문제**: Unity에서 웹으로부터 역할 정보를 정상적으로 수신하지만 `SocketManager.CurrentRole`이 빈 문자열로 남아있어 타임아웃이 발생하고, 씬 전환 시 무한루프가 발생하는 문제

**원인**: 
1. `WebCommunicationController.HandleInit`에서 `SocketManager` null 체크 강화
2. `SocketManager.CurrentRole` 프로퍼티를 읽기/쓰기 가능하도록 수정
3. `BootLoader.OnSceneUnloaded`에서 조건부 재초기화로 무한루프 방지

**수정된 파일**:
- `Assets/Scripts/Controllers/WebCommunicationController.cs`: HandleInit에서 SocketManager 역할 설정 추가
- `Assets/Scripts/Controllers/SocketManager.cs`: CurrentRole 프로퍼티를 읽기/쓰기 가능하도록 수정
- `Assets/Scripts/Controllers/BootLoader.cs`: OnSceneUnloaded에서 조건부 재초기화 적용

**예방책**:
- 역할 정보 설정 시 항상 SocketManager와 BootLoader 양쪽에 알림
- 씬 전환 시 초기화 상태를 신중하게 관리
- 무한루프 방지를 위한 조건부 재초기화 로직 적용

---

## 재발방지책 #57: 콘솔 로그 반복 출력 방지

**문제**: Unity 콘솔에서 동일한 로그가 반복적으로 출력되어 가독성이 떨어지는 문제

**해결책**:
- 로그 출력 시 조건부로 출력하거나 주기적으로만 출력
- 디버그 모드에서만 상세 로그 출력
- 반복되는 로그는 간격을 두고 출력

**예방책**:
- 로그 출력 시 적절한 조건과 간격 설정
- 디버그 모드와 릴리즈 모드 구분
- 반복 로그는 주기적으로만 출력하도록 설정

---

## 재발방지책 #59: C# static 변수 선언 위치 오류 해결

**문제**: `SceneTransitionManager.cs`에서 메서드 내부에 `static` 변수를 선언하여 컴파일 오류 발생

**오류 메시지**: `error CS0106: The modifier 'static' is not valid for this item`

**원인**: C#에서 `static` 변수는 메서드 내부가 아닌 클래스 레벨에서 선언되어야 함

**해결책**:
```csharp
// 변경 전 (오류)
private void OnSceneUnloaded(Scene scene)
{
    static string lastUnloadedScene = "";  // 오류!
    static int unloadCount = 0;           // 오류!
    static float lastUnloadTime = 0f;     // 오류!
}

// 변경 후 (올바름)
private static string lastUnloadedScene = "";
private static int unloadCount = 0;
private static float lastUnloadTime = 0f;

private void OnSceneUnloaded(Scene scene)
{
    // 메서드 내용
}
```

**예방책**:
1. `static` 변수는 항상 클래스 레벨에서 선언
2. 메서드 내부에서는 `static` 변수 선언 불가
3. 컴파일 오류 발생 시 즉시 수정 및 테스트

---

## 재발방지책 #60: Unity WebGL "null function or function signature mismatch" 오류 해결

**문제**: Unity WebGL에서 "RuntimeError: null function or function signature mismatch" 오류가 발생하여 앱이 중단되는 문제

**오류 메시지**:
```
RuntimeError: null function or function signature mismatch
at wasm://wasm/07397222:wasm-function[49111]:0xe29c40
```

**원인**: 
1. Unity WebGL 빌드에서 JavaScript 함수 호출 시 시그니처 불일치
2. PostMessage.jslib의 함수 정의와 실제 호출 간 차이
3. Unity 버전 업데이트로 인한 WebGL API 변경
4. 메모리 관리 문제로 인한 함수 포인터 손실

**해결책**:

1. **PostMessage.jslib 함수 시그니처 확인 및 수정**:
```javascript
// PostMessage.jslib
mergeInto(LibraryManager.library, {
    SendMessageToWeb: function(message) {
        try {
            var messageStr = UTF8ToString(message);
            console.log('Unity → 웹: 메시지 전송:', messageStr);
            
            // 메시지 전송
            if (window.parent && window.parent !== window) {
                window.parent.postMessage(JSON.parse(messageStr), '*');
            }
        } catch (error) {
            console.error('SendMessageToWeb 오류:', error);
        }
    },
    
    InitPostMessageListenerInternal: function() {
        try {
            console.log('=== 재발방지책 #60: InitPostMessageListenerInternal 호출됨 ===');
            
            // 기존 리스너 제거 (중복 방지)
            if (window.unityMessageListener) {
                window.removeEventListener('message', window.unityMessageListener);
            }
            
            // 새로운 리스너 생성
            window.unityMessageListener = function(e) {
                try {
                    if (e.data && typeof e.data === 'object') {
                        var message = e.data;
                        console.log('Unity → React 메시지 수신:', message);
                        
                        // Unity 인스턴스 확인
                        if (window.unityInstance && window.unityInstance.SendMessage) {
                            var fullMessage = JSON.stringify(message);
                            
                            // 안전한 함수 호출
                            try {
                                window.unityInstance.SendMessage('WebCommunicationController', 'ReceiveMessageFromWeb', fullMessage);
                                console.log('Unity에 메시지 전달 성공');
                            } catch (unityError) {
                                console.warn('WebCommunicationController not found, trying SocketManager fallback');
                                try {
                                    window.unityInstance.SendMessage('SocketManager', 'OnBrowserMessage', fullMessage);
                                    console.log('Unity에 메시지 전달 성공 (SocketManager 폴백)');
                                } catch (fallbackError) {
                                    console.error('모든 Unity 컨트롤러를 찾을 수 없습니다:', fallbackError);
                                }
                            }
                        } else {
                            console.warn('Unity 인스턴스가 준비되지 않았습니다');
                        }
                    }
                } catch (error) {
                    console.error('메시지 처리 오류:', error);
                }
            };
            
            // 리스너 등록
            window.addEventListener('message', window.unityMessageListener);
            console.log('메시지 리스너 등록 완료');
            
        } catch (error) {
            console.error('InitPostMessageListenerInternal 오류:', error);
        }
    }
});
```

2. **Unity C# 스크립트에서 안전한 함수 호출**:
```csharp
// WebCommunicationController.cs
[DllImport("__Internal")]
private static extern void SendMessageToWeb(string message);

public void SendToWeb(string type, string data)
{
    try {
        var message = JsonUtility.ToJson(new WebMessage { type = type, data = data });
        SendMessageToWeb(message);
    } catch (Exception e) {
        Debug.LogError($"SendToWeb 오류: {e.Message}");
    }
}

public void ReceiveMessageFromWeb(string message)
{
    try {
        Debug.Log($"웹에서 메시지 수신: {message}");
        // 메시지 처리 로직
    } catch (Exception e) {
        Debug.LogError($"ReceiveMessageFromWeb 오류: {e.Message}");
    }
}
```

3. **Unity WebGL 빌드 설정 확인**:
   - Build Settings → Platform → WebGL 선택
   - Player Settings → Publishing Settings → Compression Format: Disabled
   - Player Settings → Publishing Settings → Enable Exceptions: Full
   - Player Settings → Publishing Settings → Development Build: 체크

4. **메모리 관리 개선**:
```javascript
// 메모리 누수 방지
function cleanupUnityResources() {
    if (window.unityInstance) {
        try {
            window.unityInstance.Quit();
        } catch (error) {
            console.warn('Unity 정리 중 오류:', error);
        }
        window.unityinstance = null;
    }
    
    if (window.unityMessageListener) {
        window.removeEventListener('message', window.unityMessageListener);
        window.unityMessageListener = null;
    }
}

// 페이지 언로드 시 정리
window.addEventListener('beforeunload', cleanupUnityResources);
```

**예방책**:
1. Unity WebGL 빌드 시 항상 Development Build로 테스트
2. PostMessage.jslib 함수 시그니처 정기적 확인
3. JavaScript 함수 호출 시 try-catch 블록 필수
4. 메모리 누수 방지를 위한 정리 함수 구현
5. Unity 버전 업데이트 시 WebGL API 변경사항 확인

**주의사항**:
- 이 수정으로 인해 씬 전환 문제가 재발할 수 있으므로 기존 재발방지책 #46, #47, #48, #50 유지
- 함수 시그니처 변경 시 Unity 재빌드 필수
- Development Build에서 충분한 테스트 후 Production Build 진행

---

## 재발방지책 #62: Unity 프로젝트 메타데이터 및 패키지 오류 해결

**문제:** Unity 프로젝트에서 다음과 같은 오류 발생:
- `Could not extract GUID in text file Assets/Resources/AutoInitializer.prefab at line 44`
- `Broken text PPtr. GUID 00000000000000000000000000000000 fileID 11500000 is invalid!`
- `The following asset(s) located in immutable packages were unexpectedly altered`

**원인:**
1. 프리팹 파일에서 스크립트 참조의 GUID가 잘못 설정됨
2. Unity 패키지 파일들이 예상치 못하게 변경됨
3. 메타데이터 파일 손상

**해결책:**

1. **프리팹 스크립트 참조 수정:**
```yaml
# 변경 전 (오류)
m_Script: {fileID: 11500000, guid: 00000000000000000000000000000000, type: 3}

# 변경 후 (올바름)
m_Script: {fileID: 11500000, guid: b5f343d4c95f3e746b57e625c6111faa, type: 3}
```

2. **올바른 GUID 찾기:**
   - 스크립트 파일의 `.meta` 파일에서 GUID 확인
   - 예: `Assets/Scripts/Controllers/AutoInitializer.cs.meta`에서 `guid: b5f343d4c95f3e746b57e625c6111faa`

3. **프로젝트 정리:**
   ```bash
   # Unity 프로세스 종료
   taskkill /IM Unity.exe /F
   
   # 캐시 폴더 삭제
   Remove-Item -Recurse -Force Library, Temp
   
   # Unity 재시작
   & "C:\Program Files\Unity\Hub\Editor\2022.3.5f1\Editor\Unity.exe" -projectPath .
   ```

4. **패키지 복구:**
   - Unity Editor에서 Window → Package Manager 열기
   - 변경된 패키지들 확인 및 복구
   - 필요한 경우 패키지 재설치

**예방책:**
1. 프리팹 생성 시 올바른 스크립트 참조 확인
2. 메타데이터 파일 백업
3. 정기적인 프로젝트 정리
4. Unity 버전 업데이트 시 주의

---

## 최신 업데이트
**버전:** 3.21  
**총 재발방지책 수:** 76  
**최종 업데이트:** 2024년 1월

### 최근 추가된 재발방지책:
- 재발방지책 #76: WebGL 빌드 설정 완전 검증
- 재발방지책 #75: 통신과 함수 재등록의 통합 해결
- 재발방지책 #74: 수정사항으로 인한 부작용 방지 체계
- 재발방지책 #73: Unity WebGL 역할 정보 수신 실패 문제 해결
- 재발방지책 #72: 통신 관련 재발방지책 통합 검증 절차
- 재발방지책 #71: 통신 관련 수정사항 검증 체크리스트
- 재발방지책 #70: Unity WebGL 메시지 전송 실패 문제 해결
- 재발방지책 #69: Unity WebGL "null function or function signature mismatch" 오류 근본적 해결
- 재발방지책 #68: Unity WebGL 런타임 "null function or function signature mismatch" 오류 재발 해결
- 재발방지책 #67: Unity WebGL 빌드 시 undefined symbol 링커 오류 해결
- 재발방지책 #66: Unity WebGL 빌드 시 PostMessage.jslib 컴파일 오류 해결
- 재발방지책 #65: Unity WebGL "null function or function signature mismatch" 오류 근본 해결

### 재발방지책 #63: Unity VirtualArtifacts 오류 해결
**문제:** `Opening file VirtualArtifacts/Primary/e2df8c7948910f14c84ae2b47778956d: 지정된 경로를 찾을 수 없습니다`
**원인:** Unity의 내부 아티팩트 데이터베이스가 손상되었거나 프로젝트 상태가 불안정함
**해결책:**
1. **Unity Editor 완전 종료**
   ```powershell
   taskkill /IM Unity.exe /F
   taskkill /IM UnityEditor.exe /F
   ```

2. **프로젝트 캐시 완전 정리**
   ```powershell
   # Unity 프로젝트 폴더에서
   Remove-Item -Path "Library" -Recurse -Force -ErrorAction SilentlyContinue
   Remove-Item -Path "Temp" -Recurse -Force -ErrorAction SilentlyContinue
   Remove-Item -Path "Logs" -Recurse -Force -ErrorAction SilentlyContinue
   ```

3. **Unity Hub에서 프로젝트 재등록**
   - Unity Hub → Projects → Add → 프로젝트 폴더 선택
   - Unity Editor에서 프로젝트 열기

4. **프로젝트 재컴파일**
   - Unity Editor에서 Assets → Reimport All
   - 잠시 기다린 후 빌드 시도

5. **대안: 새 프로젝트로 마이그레이션**
   - 새 Unity 프로젝트 생성
   - Assets 폴더만 복사
   - ProjectSettings 폴더는 복사하지 않음

**주의사항:** VirtualArtifacts 오류는 Unity의 내부 데이터베이스 문제이므로 프로젝트를 함부로 건드리지 말고 위 단계를 순서대로 진행

### 재발방지책 #64: Unity 버전 불일치로 인한 패키지 오류 해결
**문제:** `Project has invalid dependencies: Package [com.unity.feature.2d@2.0.1] cannot be found`
**원인:** 프로젝트 버전(6000.1.0f1)과 Unity Editor 버전(2022.3.5f1) 불일치
**해결책:**
1. **Unity Hub에서 올바른 버전 설치**
   - Unity Hub → Installs → Unity 6000.1.0f1 설치
   - 또는 프로젝트를 2022.3.5f1에 맞게 마이그레이션

2. **프로젝트 버전 변경 (권장)**
   ```powershell
   # ProjectVersion.txt 수정
   m_EditorVersion: 2022.3.5f1
   m_EditorVersionWithRevision: 2022.3.5f1 (9674261d40ee)
   ```

3. **패키지 매니페스트 업데이트**
   - Unity Editor에서 Window → Package Manager
   - 모든 패키지를 현재 버전에 맞게 업데이트

4. **프로젝트 재컴파일**
   - Assets → Reimport All
   - Library 폴더 삭제 후 재생성

**주의사항:** 버전 변경 시 일부 스크립트나 에셋이 호환되지 않을 수 있으므로 백업 필수

### 재발방지책 #65: Unity WebGL "null function or function signature mismatch" 오류 근본 해결

**문제:** Unity WebGL에서 "RuntimeError: null function or function signature mismatch" 오류가 반복적으로 발생하여 앱이 중단되는 문제

**오류 메시지:**
```
RuntimeError: null function or function signature mismatch
at wasm://wasm/07399c6e:wasm-function[49115]:0xe29ef4
```

**근본 원인:**
1. **Unity WebGL 빌드 설정 문제**: Development Build가 아닌 Production Build에서 발생
2. **JavaScript 함수 시그니처 불일치**: C# DllImport와 JavaScript 함수 정의 간 차이
3. **메모리 관리 문제**: WebAssembly 메모리 누수로 인한 함수 포인터 손실
4. **Unity 버전 호환성**: Unity 2022.3.5f1에서 WebGL API 변경사항
5. **함수 호출 타이밍**: Unity 초기화 완료 전에 JavaScript 함수 호출

**근본 해결책:**

1. **Unity WebGL 빌드 설정 강화:**
   ```
   Build Settings:
   - Platform: WebGL
   - Development Build: ✅ 체크 (반드시 필수)
   - Compression Format: Disabled
   - Enable Exceptions: Full
   - Data Caching: Enabled
   - Memory Size: 512MB
   - Code Optimization: Size
   ```

2. **PostMessage.jslib 함수 시그니처 완전 재정의:**
```javascript
// PostMessage.jslib - 모든 함수를 안전한 시그니처로 재정의
mergeInto(LibraryManager.library, {
    // 기본 메시지 전송 함수 (가장 안전한 버전)
    SendMessageToWeb: function(messagePtr) {
        try {
            if (!messagePtr) {
                console.warn('SendMessageToWeb: messagePtr이 null');
                return;
            }
            
            var messageStr = UTF8ToString(messagePtr);
            if (!messageStr) {
                console.warn('SendMessageToWeb: messageStr이 null');
                return;
            }
            
            console.log('Unity → 웹: 메시지 전송:', messageStr);
            
            // 부모 창으로 메시지 전송
            if (window.parent && window.parent !== window) {
                try {
                    var parsedMessage = JSON.parse(messageStr);
                    window.parent.postMessage({
                        source: 'unity',
                        message: messageStr,
                        timestamp: Date.now()
                    }, '*');
                } catch (parseError) {
                    console.warn('메시지 파싱 실패, 원본 전송:', messageStr);
                    window.parent.postMessage({
                        source: 'unity',
                        message: messageStr,
                        timestamp: Date.now()
                    }, '*');
                }
            }
        } catch (error) {
            console.error('SendMessageToWeb 오류:', error);
        }
    },
    
    // 안전한 메시지 전송 함수 (재발방지책 #60 개선)
    SendMessageToWebSafe: function(messagePtr) {
        try {
            if (!messagePtr) {
                console.warn('SendMessageToWebSafe: messagePtr이 null');
                return;
            }
            
            var messageStr = UTF8ToString(messagePtr);
            if (!messageStr) {
                console.warn('SendMessageToWebSafe: messageStr이 null');
                return;
            }
            
            console.log('Unity → 웹 (Safe): 메시지 전송:', messageStr);
            
            // 부모 창으로 메시지 전송
            if (window.parent && window.parent !== window) {
                window.parent.postMessage({
                    source: 'unity',
                    message: messageStr,
                    timestamp: Date.now()
                }, '*');
            }
        } catch (error) {
            console.error('SendMessageToWebSafe 오류:', error);
        }
    },
    
    // 메모리 관리 함수들 (재발방지책 #22 개선)
    StringToIntPtr: function(str) {
        try {
            if (!str) {
                return 0;
            }
            var length = lengthBytesUTF8(str) + 1;
            var ptr = _malloc(length);
            if (ptr === 0) {
                console.error('StringToIntPtr: 메모리 할당 실패');
                return 0;
            }
            stringToUTF8(str, ptr, length);
            return ptr;
        } catch (error) {
            console.error('StringToIntPtr 오류:', error);
            return 0;
        }
    },
    
    FreeIntPtr: function(ptr) {
        try {
            if (ptr && ptr !== 0) {
                _free(ptr);
            }
        } catch (error) {
            console.error('FreeIntPtr 오류:', error);
        }
    },
    
    // 메시지 리스너 초기화 (재발방지책 #60 개선)
    InitPostMessageListenerInternal: function() {
        console.log('=== 재발방지책 #65: InitPostMessageListenerInternal 호출됨 ===');
        try {
            // 기존 리스너 제거 (중복 방지)
            if (window.unityMessageListener) {
                window.removeEventListener('message', window.unityMessageListener);
                console.log('기존 메시지 리스너 제거됨');
            }
            
            // 이미 초기화되었는지 확인
            if (window.__unityPMReady) {
                console.log('PostMessage 리스너가 이미 초기화됨');
                return;
            }
            window.__unityPMReady = true;
            
            // 메시지 큐 초기화
            if (!window.__messageQueue) {
                window.__messageQueue = [];
            }
            
            // 안전한 메시지 리스너 등록
            window.unityMessageListener = function(e) {
                try {
                    if (!e.data || !e.data.type) {
                        return;
                    }
                    
                    console.log('메시지 수신:', e.data.type);
                    
                    // Unity 인스턴스 확인
                    var target = window.unityInstance || window.Module;
                    if (!target || !target.SendMessage || typeof target.SendMessage !== 'function') {
                        console.warn('Unity 인스턴스가 준비되지 않음');
                        return;
                    }
                    
                    // 메시지 전달
                    var messageData = typeof e.data.data === 'string' ? e.data.data : JSON.stringify(e.data.data || '');
                    var fullMessage = JSON.stringify({
                        type: e.data.type,
                        data: messageData
                    });
                    
                    // 안전한 함수 호출
                    try {
                        if (e.data.type === 'init') {
                            target.SendMessage('WebCommunicationController', 'ReceiveMessageFromWeb', fullMessage);
                        } else {
                            target.SendMessage('SocketManager', 'OnBrowserMessage', fullMessage);
                        }
                        console.log('메시지 전달 성공');
                    } catch (error) {
                        console.error('메시지 전달 실패:', error);
                    }
                } catch (error) {
                    console.error('메시지 리스너 오류:', error);
                }
            };
            
            // 리스너 등록
            window.addEventListener('message', window.unityMessageListener);
            console.log('메시지 리스너 등록 완료');
            
        } catch (error) {
            console.error('InitPostMessageListenerInternal 오류:', error);
        }
    }
});
```

3. **Unity C# 스크립트에서 안전한 함수 호출 강화:**
```csharp
// WebCommunicationController.cs - DllImport 시그니처 완전 일치
[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void SendMessageToWeb(string message);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void SendMessageToWebSafe(string message);

public void SendMessageToWeb(string type, string data)
{
    if (Application.platform != RuntimePlatform.WebGLPlayer)
    {
        Debug.LogWarning("WebGL이 아닌 플랫폼에서 SendMessageToWeb 호출됨");
        return;
    }
    
    try
    {
        var messageJson = JsonUtility.ToJson(new WebMessage { type = type, data = data });
        
        // 안전한 함수 호출 (재발방지책 #65)
        SendMessageToWebSafe(messageJson);
        
        if (debugMode)
        {
            Debug.Log($"웹으로 메시지 전송: {type} - {data}");
        }
    }
    catch (Exception e)
    {
        Debug.LogError($"SendMessageToWeb 오류: {e.Message}");
        
        // 폴백: 원본 방식으로 재시도
        try
        {
            var messageJson = JsonUtility.ToJson(new WebMessage { type = type, data = data });
            SendMessageToWeb(messageJson);
        }
        catch (Exception fallbackError)
        {
            Debug.LogError($"SendMessageToWeb 폴백도 실패: {fallbackError.Message}");
        }
    }
}

public void ReceiveMessageFromWeb(string messageJson)
{
    try
    {
        if (string.IsNullOrEmpty(messageJson))
        {
            Debug.LogWarning("ReceiveMessageFromWeb: 빈 메시지");
            return;
        }
        
        Debug.Log($"웹에서 메시지 수신: {messageJson}");
        
        // 메시지 처리 로직
        var webMessage = JsonUtility.FromJson<WebMessage>(messageJson);
        if (webMessage != null)
        {
            HandleMessage(webMessage.type, webMessage.data);
        }
    }
    catch (Exception e)
    {
        Debug.LogError($"ReceiveMessageFromWeb 오류: {e.Message}");
    }
}
```

4. **Unity WebGL 빌드 전 필수 체크리스트:**
   ```
   □ Unity Editor에서 Development Build 체크
   □ Player Settings → Publishing Settings → Compression Format: Disabled
   □ Player Settings → Publishing Settings → Enable Exceptions: Full
   □ Player Settings → Publishing Settings → Memory Size: 512MB
   □ PostMessage.jslib 파일이 Assets/Plugins/WebGL/ 폴더에 있는지 확인
   □ WebCommunicationController 스크립트가 씬에 있는지 확인
   □ 모든 DllImport 시그니처가 JavaScript 함수와 일치하는지 확인
   ```

5. **메모리 누수 방지 및 정리 함수:**
```javascript
// PostMessage.jslib에 추가
cleanupUnityResources: function() {
    try {
        // Unity 인스턴스 정리
        if (window.unityinstance) {
            try {
                window.unityinstance.Quit();
            } catch (error) {
                console.warn('Unity 정리 중 오류:', error);
            }
            window.unityinstance = null;
        }
        
        // 메시지 리스너 정리
        if (window.unityMessageListener) {
            window.removeEventListener('message', window.unityMessageListener);
            window.unityMessageListener = null;
        }
        
        // 메시지 큐 정리
        if (window.__messageQueue) {
            window.__messageQueue.length = 0;
        }
        
        // 전역 변수 정리
        window.__unityPMReady = false;
        
        console.log('Unity 리소스 정리 완료');
    } catch (error) {
        console.error('cleanupUnityResources 오류:', error);
    }
}
```

6. **페이지 언로드 시 자동 정리:**
```javascript
// 페이지 언로드 시 자동 정리
window.addEventListener('beforeunload', function() {
    if (window.cleanupUnityResources) {
        window.cleanupUnityResources();
    }
});
```

**예방책:**
1. **항상 Development Build로 테스트**: Production Build에서는 디버그 정보가 제거되어 오류 추적이 어려움
2. **정기적인 메모리 정리**: Unity 인스턴스와 리스너 정리 함수 구현
3. **함수 시그니처 정기 확인**: C# DllImport와 JavaScript 함수 정의 일치 확인
4. **에러 핸들링 강화**: 모든 JavaScript 함수 호출에 try-catch 블록 필수
5. **Unity 버전 업데이트 시 주의**: WebGL API 변경사항 확인

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #46, #47, #48, #50, #60과 호환성 유지
- Development Build에서 충분한 테스트 후 Production Build 진행
- 메모리 누수 방지를 위한 정기적인 정리 함수 호출
- Unity WebGL 빌드 설정의 일관성 유지

**현재 상태:** ✅ 재발방지책 #65 적용으로 근본적인 해결책 제시

---

## 재발방지책 #66: Unity WebGL 빌드 시 PostMessage.jslib 컴파일 오류 해결

**문제:** Unity WebGL 빌드 시 PostMessage.jslib에서 `ReferenceError: window is not defined` 오류 발생

**오류 메시지:**
```
ReferenceError: window is not defined
    at C:\Users\qd011\OneDrive\Desktop\quizplay\quiz-master\Assets\Plugins\WebGL\PostMessage.preprocessed.jslib:213
window.addEventListener('beforeunload', function() {
```

**원인:** 
1. **Emscripten 컴파일 환경 문제**: Unity WebGL 빌드 시 Emscripten이 Node.js 환경에서 실행됨
2. **window 객체 직접 참조**: PostMessage.jslib에서 `window` 객체를 컴파일 타임에 직접 참조
3. **beforeunload 이벤트 리스너**: 재발방지책 #65에서 추가한 이벤트 리스너가 컴파일 타임에 실행됨

**해결책:**

1. **모든 window 객체 참조를 런타임 체크로 변경:**
```javascript
// 변경 전 (오류 발생)
if (window.parent && window.parent !== window) {
    window.parent.postMessage(data, '*');
}

// 변경 후 (안전)
if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
    window.parent.postMessage(data, '*');
}
```

2. **InitPostMessageListenerInternal 함수에 런타임 체크 추가:**
```javascript
InitPostMessageListenerInternal: function() {
    console.log('=== 재발방지책 #66: InitPostMessageListenerInternal 호출됨 ===');
    try {
        // 런타임에서만 window 객체 접근
        if (typeof window === 'undefined') {
            console.warn('window 객체가 정의되지 않음 (컴파일 타임)');
            return;
        }
        
        // 기존 로직...
    } catch (error) {
        console.error('InitPostMessageListenerInternal 오류:', error);
    }
}
```

3. **cleanupUnityResources 함수에 런타임 체크 추가:**
```javascript
cleanupUnityResources: function() {
    try {
        // 런타임에서만 window 객체 접근
        if (typeof window === 'undefined') {
            return;
        }
        
        // 기존 정리 로직...
    } catch (error) {
        console.error('cleanupUnityResources 오류:', error);
    }
}
```

4. **beforeunload 이벤트 리스너를 조건부로 등록:**
```javascript
// 재발방지책 #66: 컴파일 타임에 실행되지 않도록 조건부 등록
if (typeof window !== 'undefined') {
    // 페이지 언로드 시 자동 정리 등록 (런타임에서만)
    window.addEventListener('beforeunload', function() {
        if (window.cleanupUnityResources) {
            window.cleanupUnityResources();
        }
    });
}
```

**예방책:**
1. **모든 window 객체 참조에 `typeof window !== 'undefined'` 체크 추가**
2. **Emscripten 컴파일 환경과 브라우저 런타임 환경 구분**
3. **이벤트 리스너 등록을 조건부로 처리**
4. **컴파일 타임에 실행되는 코드와 런타임에 실행되는 코드 분리**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #65의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 모든 window 객체 접근에 런타임 체크 필수

**현재 상태:** ✅ 재발방지책 #66 적용으로 컴파일 오류 해결

---

## 재발방지책 #67: Unity WebGL 빌드 시 undefined symbol 링커 오류 해결

**문제:** Unity WebGL 빌드 시 `wasm-ld: error: undefined symbol` 오류 발생

**오류 메시지:**
```
wasm-ld: error: undefined symbol: EmitToServer
wasm-ld: error: undefined symbol: SendMessageToWebInternal
wasm-ld: error: undefined symbol: SendMessageToWebGLInternal
wasm-ld: error: undefined symbol: NotifySceneTransitionCompleteInternal
wasm-ld: error: undefined symbol: ForceReinitializeJavaScriptFunctionsInternal
wasm-ld: error: undefined symbol: ConnectToSocketIOServer
```

**원인:** 
1. **C# 스크립트에서 DllImport로 선언된 함수들이 PostMessage.jslib에 정의되지 않음**
2. **함수명 불일치**: C#에서 호출하는 함수명과 JavaScript에서 정의된 함수명이 다름
3. **PostMessage.jslib에서 누락된 함수들**

**해결책:**

1. **누락된 JavaScript 함수들을 PostMessage.jslib에 추가:**
```javascript
// BootLoader.cs에서 사용하는 함수들
SendMessageToWebGLInternal: function(messagePtr) {
    try {
        if (!messagePtr) {
            console.warn('SendMessageToWebGLInternal: messagePtr이 null');
            return;
        }
        
        var messageStr = UTF8ToString(messagePtr);
        console.log('Unity → WebGL: 메시지 전송:', messageStr);
        
        // 부모 창으로 메시지 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                message: messageStr,
                timestamp: Date.now()
            }, '*');
        }
    } catch (error) {
        console.error('SendMessageToWebGLInternal 오류:', error);
    }
},

InitPostMessageListenerInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #67: InitPostMessageListenerInternal 호출됨 ===');
    // 기존 로직...
},

NotifySceneTransitionCompleteInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #67: 씬 전환 완료 알림 ===');
    try {
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                type: 'sceneTransitionComplete',
                timestamp: Date.now()
            }, '*');
        }
    } catch (error) {
        console.error('NotifySceneTransitionCompleteInternal 오류:', error);
    }
},

ForceReinitializeJavaScriptFunctionsInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #67: JavaScript 함수 강제 재등록 ===');
    // 기존 로직...
},

// SocketManager.cs에서 사용하는 함수들
SendMessageToWebInternal: function(messagePtr) {
    try {
        if (!messagePtr) {
            console.warn('SendMessageToWebInternal: messagePtr이 null');
            return;
        }
        
        var messageStr = UTF8ToString(messagePtr);
        console.log('Unity → Web (Internal): 메시지 전송:', messageStr);
        
        // 부모 창으로 메시지 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                message: messageStr,
                timestamp: Date.now()
            }, '*');
        }
    } catch (error) {
        console.error('SendMessageToWebInternal 오류:', error);
    }
},

ConnectToSocketIOServer: function(urlPtr, gameCodePtr, nicknamePtr) {
    console.log('=== 재발방지책 #67: Socket.IO 서버 연결 시도 ===');
    try {
        var url = UTF8ToString(urlPtr);
        var gameCode = UTF8ToString(gameCodePtr);
        var nickname = UTF8ToString(nicknamePtr);
        
        console.log(`Socket.IO 연결: ${url}, 게임코드: ${gameCode}, 닉네임: ${nickname}`);
        
        // 부모 창으로 연결 정보 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                type: 'connectToSocketIO',
                data: {
                    url: url,
                    gameCode: gameCode,
                    nickname: nickname
                },
                timestamp: Date.now()
            }, '*');
        }
        
        return 1; // 성공
    } catch (error) {
        console.error('ConnectToSocketIOServer 오류:', error);
        return 0; // 실패
    }
},

EmitToServer: function(eventNamePtr, dataPtr) {
    console.log('=== 재발방지책 #67: Socket.IO 이벤트 전송 ===');
    try {
        var eventName = UTF8ToString(eventNamePtr);
        var data = UTF8ToString(dataPtr);
        
        console.log(`Socket.IO 이벤트: ${eventName}, 데이터: ${data}`);
        
        // 부모 창으로 이벤트 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                type: 'emitToSocketIO',
                data: {
                    eventName: eventName,
                    data: data
                },
                timestamp: Date.now()
            }, '*');
        }
        
        return 1; // 성공
    } catch (error) {
        console.error('EmitToServer 오류:', error);
        return 0; // 실패
    }
}
```

2. **함수 시그니처 일치 확인:**
   - C#의 `DllImport` 선언과 JavaScript 함수 정의가 정확히 일치해야 함
   - 매개변수 타입과 반환 타입 확인
   - 함수명 철자 확인

3. **메모리 관리 함수들 포함:**
```javascript
StringToIntPtr: function(str) {
    try {
        if (!str) {
            return 0;
        }
        var length = lengthBytesUTF8(str) + 1;
        var ptr = _malloc(length);
        if (ptr === 0) {
            console.error('StringToIntPtr: 메모리 할당 실패');
            return 0;
        }
        stringToUTF8(str, ptr, length);
        return ptr;
    } catch (error) {
        console.error('StringToIntPtr 오류:', error);
        return 0;
    }
},

FreeIntPtr: function(ptr) {
    try {
        if (ptr && ptr !== 0) {
            _free(ptr);
        }
    } catch (error) {
        console.error('FreeIntPtr 오류:', error);
    }
}
```

**예방책:**
1. **C# DllImport 선언과 JavaScript 함수 정의 일치 확인**
2. **새로운 함수 추가 시 PostMessage.jslib에도 동일한 함수 정의**
3. **함수명 철자와 매개변수 타입 정확히 확인**
4. **메모리 관리 함수들도 함께 정의**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #65, #66의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 모든 함수 시그니처가 정확히 일치해야 함

**현재 상태:** ✅ 재발방지책 #67 적용으로 undefined symbol 오류 해결

---

## 재발방지책 #68: Unity WebGL 런타임 "null function or function signature mismatch" 오류 재발 해결

**문제:** Unity WebGL 런타임에서 "RuntimeError: null function or function signature mismatch" 오류가 재발하고, React에서 "undefined" is not valid JSON 파싱 오류 발생

**오류 메시지:**
```
RuntimeError: null function or function signature mismatch
at wasm://wasm/07398dc6:wasm-function[49115]:0xe29ef3

UnityPage.tsx:66 Unity 메시지 파싱 오류: SyntaxError: "undefined" is not valid JSON
```

**원인:** 
1. **재발방지책 #67에서 추가한 함수들의 시그니처 불일치**
2. **C#에서 호출하는 함수와 JavaScript에서 정의된 함수의 매개변수 타입 불일치**
3. **IntPtr 매개변수 처리 방식 문제**
4. **메모리 관리 함수들의 반환 타입 불일치**
5. **Unity에서 undefined 값을 전송하여 React에서 JSON.parse 실패**

**해결책:**

1. **C# DllImport와 JavaScript 함수 시그니처 완전 일치:**
```javascript
// BootLoader.cs에서 사용하는 함수들 - IntPtr 매개변수
SendMessageToWebGLInternal: function(messagePtr) {
    try {
        if (!messagePtr) {
            console.warn('SendMessageToWebGLInternal: messagePtr이 null');
            return;
        }
        
        var messageStr = UTF8ToString(messagePtr);
        console.log('Unity → WebGL: 메시지 전송:', messageStr);
        
        // 부모 창으로 메시지 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                message: messageStr,
                timestamp: Date.now()
            }, '*');
        }
    } catch (error) {
        console.error('SendMessageToWebGLInternal 오류:', error);
    }
},

InitPostMessageListenerInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #68: InitPostMessageListenerInternal 호출됨 ===');
    // 기존 로직...
},

NotifySceneTransitionCompleteInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #68: 씬 전환 완료 알림 ===');
    // 기존 로직...
},

ForceReinitializeJavaScriptFunctionsInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #68: JavaScript 함수 강제 재등록 ===');
    // 기존 로직...
},

// SocketManager.cs에서 사용하는 함수들 - IntPtr 매개변수
SendMessageToWebInternal: function(messagePtr) {
    try {
        if (!messagePtr) {
            console.warn('SendMessageToWebInternal: messagePtr이 null');
            return;
        }
        
        var messageStr = UTF8ToString(messagePtr);
        console.log('Unity → Web (Internal): 메시지 전송:', messageStr);
        
        // 부모 창으로 메시지 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                message: messageStr,
                timestamp: Date.now()
            }, '*');
        }
    } catch (error) {
        console.error('SendMessageToWebInternal 오류:', error);
    }
},

ConnectToSocketIOServer: function(urlPtr, gameCodePtr, nicknamePtr) {
    console.log('=== 재발방지책 #68: Socket.IO 서버 연결 시도 ===');
    try {
        var url = UTF8ToString(urlPtr);
        var gameCode = UTF8ToString(gameCodePtr);
        var nickname = UTF8ToString(nicknamePtr);
        
        console.log(`Socket.IO 연결: ${url}, 게임코드: ${gameCode}, 닉네임: ${nickname}`);
        
        // 부모 창으로 연결 정보 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                type: 'connectToSocketIO',
                data: {
                    url: url,
                    gameCode: gameCode,
                    nickname: nickname
                },
                timestamp: Date.now()
            }, '*');
        }
        
        return 1; // 성공
    } catch (error) {
        console.error('ConnectToSocketIOServer 오류:', error);
        return 0; // 실패
    }
},

EmitToServer: function(eventNamePtr, dataPtr) {
    console.log('=== 재발방지책 #68: Socket.IO 이벤트 전송 ===');
    try {
        var eventName = UTF8ToString(eventNamePtr);
        var data = UTF8ToString(dataPtr);
        
        console.log(`Socket.IO 이벤트: ${eventName}, 데이터: ${data}`);
        
        // 부모 창으로 이벤트 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                type: 'emitToSocketIO',
                data: {
                    eventName: eventName,
                    data: data
                },
                timestamp: Date.now()
            }, '*');
        }
        
        return 1; // 성공
    } catch (error) {
        console.error('EmitToServer 오류:', error);
        return 0; // 실패
    }
}
```

2. **React에서 undefined 값 안전 처리:**
```typescript
// UnityPage.tsx
const handleUnityMessage = (event: MessageEvent) => {
    if (event.source !== unityRef.current?.contentWindow) return;

    console.log('Unity → React 메시지 수신:', event.data);

    // Unity에서 보내는 메시지 형식 처리
    if (event.data && event.data.source === 'unity') {
        try {
            // 재발방지책 #68: undefined 값 안전 처리
            const messageStr = event.data.message;
            if (!messageStr || messageStr === 'undefined' || messageStr === 'null') {
                console.warn('Unity에서 빈 메시지 수신:', messageStr);
                return;
            }
            
            const unityMessage = JSON.parse(messageStr);
            console.log('Unity 메시지 파싱됨:', unityMessage);
            
            if (unityMessage.type === 'unity-loaded') {
                console.log('Unity 로딩 완료, 초기화 메시지 전송');
                setTimeout(sendInitMessage, 500);
            }
        } catch (error) {
            console.error('Unity 메시지 파싱 오류:', error, '원본 데이터:', event.data);
        }
    }
    
    // 기존 형식도 지원 (backward compatibility)
    const { type } = event.data || {};
    if (type === 'unity-ready') {
        console.log('Unity 준비됨, 초기화 메시지 전송');
        setTimeout(sendInitMessage, 500);
    }
};
```

3. **메모리 관리 함수들 C# 시그니처와 완전 일치:**
```javascript
// 메모리 관리 함수들 (재발방지책 #22 개선) - C# 시그니처와 완전 일치
StringToIntPtr: function(str) {
    try {
        if (!str) {
            return 0;
        }
        var length = lengthBytesUTF8(str) + 1;
        var ptr = _malloc(length);
        if (ptr === 0) {
            console.error('StringToIntPtr: 메모리 할당 실패');
            return 0;
        }
        stringToUTF8(str, ptr, length);
        return ptr;
    } catch (error) {
        console.error('StringToIntPtr 오류:', error);
        return 0;
    }
},

FreeIntPtr: function(ptr) {
    try {
        if (ptr && ptr !== 0) {
            _free(ptr);
        }
    } catch (error) {
        console.error('FreeIntPtr 오류:', error);
    }
}
```

**예방책:**
1. **C# DllImport 선언과 JavaScript 함수 정의 정확히 일치 확인**
2. **IntPtr 매개변수 처리 시 UTF8ToString 사용**
3. **메모리 관리 함수들의 반환 타입 일치 확인**
4. **React에서 undefined/null 값 안전 처리**
5. **모든 함수 시그니처 정기적 검증**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #65, #66, #67의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 모든 함수 시그니처가 정확히 일치해야 함
- React에서 메시지 파싱 시 안전성 검증 필수

**현재 상태:** ✅ 재발방지책 #68 적용으로 런타임 오류 해결

---

## 재발방지책 #68.1: 재발방지책 간 충돌 해결

**문제:** 재발방지책 #65, #66, #67, #68 간의 충돌 발생

**충돌 내용:**
1. **로그 메시지 충돌**: 재발방지책 #67과 #68에서 동일한 함수에 다른 로그 메시지 사용
2. **빌드 파일 충돌**: 이전 버전의 재발방지책 #67 코드가 빌드된 파일에 남아있음
3. **함수 시그니처 중복**: 여러 재발방지책에서 동일한 함수를 다르게 정의

**해결책:**

1. **모든 로그 메시지를 재발방지책 #68 (통합)으로 통일:**
```javascript
// 변경 전 (충돌)
console.log('=== 재발방지책 #67: InitPostMessageListenerInternal 호출됨 ===');
console.log('=== 재발방지책 #68: InitPostMessageListenerInternal 호출됨 ===');

// 변경 후 (통합)
console.log('=== 재발방지책 #68 (통합): InitPostMessageListenerInternal 호출됨 ===');
```

2. **재발방지책 #68에서 모든 이전 재발방지책 기능 통합:**
   - 재발방지책 #65: WebGL "null function" 오류 해결
   - 재발방지책 #66: 컴파일 오류 해결
   - 재발방지책 #67: undefined symbol 오류 해결
   - 재발방지책 #68: 런타임 오류 재발 해결

3. **빌드 파일 정리:**
   - Unity WebGL 재빌드로 이전 버전 코드 제거
   - Development Build로 최신 코드 적용

**예방책:**
1. **새로운 재발방지책 추가 시 기존 재발방지책과 충돌 확인**
2. **로그 메시지에 재발방지책 번호 명시**
3. **함수 시그니처 변경 시 모든 관련 파일 업데이트**
4. **빌드 후 이전 버전 코드 정리 확인**

**현재 상태:** ✅ 재발방지책 간 충돌 해결 완료

---

## 재발방지책 #69: Unity WebGL "null function or function signature mismatch" 오류 근본적 해결

**문제:** 재발방지책 #68을 적용했음에도 불구하고 동일한 "RuntimeError: null function or function signature mismatch" 오류가 재발

**오류 메시지:**
```
RuntimeError: null function or function signature mismatch
at wasm://wasm/07398dc6:wasm-function[49115]:0xe29ef3
```

**원인:** 
1. **빌드된 파일이 업데이트되지 않음**: Unity WebGL 재빌드가 필요
2. **함수 시그니처 불일치**: C# DllImport와 JavaScript 함수 정의가 여전히 불일치
3. **메모리 관리 문제**: IntPtr 처리 방식에 문제
4. **재발방지책 #68에서 누락된 부분**: 일부 함수가 제대로 정의되지 않음

**해결책:**

1. **C# DllImport 시그니처를 JavaScript와 완전히 일치하도록 수정:**
```csharp
// BootLoader.cs - 재발방지책 #69 (근본적 해결)
[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void SendMessageToWebGLInternal(IntPtr message);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void InitPostMessageListenerInternal(IntPtr empty);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void NotifySceneTransitionCompleteInternal(IntPtr empty);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void ForceReinitializeJavaScriptFunctionsInternal(IntPtr empty);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern IntPtr StringToIntPtr(string str);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void FreeIntPtr(IntPtr ptr);
```

2. **안전한 래퍼 함수들에 플랫폼 체크 추가:**
```csharp
public void SendMessageToWebGL(string message)
{
    if (Application.platform != RuntimePlatform.WebGLPlayer)
    {
        Debug.LogWarning("WebGL이 아닌 플랫폼에서 SendMessageToWebGL 호출됨");
        return;
    }
    
    IntPtr messagePtr = StringToIntPtr(message);
    try
    {
        SendMessageToWebGLInternal(messagePtr);
    }
    catch (System.Exception e)
    {
        Debug.LogError($"SendMessageToWebGL 오류: {e.Message}");
    }
    finally
    {
        FreeIntPtr(messagePtr);
    }
}
```

3. **JavaScript 함수 시그니처를 C#과 완전히 일치하도록 수정:**
```javascript
// PostMessage.jslib - 재발방지책 #69 (근본적 해결)
SendMessageToWebGLInternal: function(messagePtr) {
    try {
        if (!messagePtr) {
            console.warn('SendMessageToWebGLInternal: messagePtr이 null');
            return;
        }
        
        var messageStr = UTF8ToString(messagePtr);
        console.log('Unity → WebGL: 메시지 전송:', messageStr);
        
        // 부모 창으로 메시지 전송
        if (typeof window !== 'undefined' && window.parent && window.parent !== window) {
            window.parent.postMessage({
                source: 'unity',
                message: messageStr,
                timestamp: Date.now()
            }, '*');
        }
    } catch (error) {
        console.error('SendMessageToWebGLInternal 오류:', error);
    }
},

InitPostMessageListenerInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #69 (근본적 해결): InitPostMessageListenerInternal 호출됨 ===');
    // 기존 로직...
},

NotifySceneTransitionCompleteInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #69 (근본적 해결): 씬 전환 완료 알림 ===');
    // 기존 로직...
},

ForceReinitializeJavaScriptFunctionsInternal: function(emptyPtr) {
    console.log('=== 재발방지책 #69 (근본적 해결): JavaScript 함수 강제 재등록 ===');
    // 기존 로직...
}
```

4. **SocketManager.cs도 동일하게 수정:**
```csharp
// SocketManager.cs - 재발방지책 #69 (근본적 해결)
[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void SendMessageToWebInternal(IntPtr message);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern int ConnectToSocketIOServer(IntPtr url, IntPtr gameCode, IntPtr nickname);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern int EmitToServer(IntPtr eventName, IntPtr data);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern IntPtr StringToIntPtr(string str);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void FreeIntPtr(IntPtr ptr);
```

**예방책:**
1. **C# DllImport 선언과 JavaScript 함수 정의 정확히 일치 확인**
2. **플랫폼 체크 추가로 WebGL이 아닌 환경에서 오류 방지**
3. **메모리 관리 함수들을 DllImport로 통일**
4. **Unity WebGL 재빌드로 최신 코드 적용**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #65, #66, #67, #68의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 모든 함수 시그니처가 정확히 일치해야 함
- 빌드 후 이전 버전 코드 정리 확인

**현재 상태:** ✅ 재발방지책 #69 적용으로 근본적 해결

---

## 재발방지책 #70: Unity WebGL 메시지 전송 실패 문제 해결

**문제:** 재발방지책 #69 적용 후 Unity WebGL에서 React로 메시지가 전송되지 않아 기본 씬으로 넘어가는 문제 발생

**증상:**
- Unity WebGL이 정상적으로 로드되고 통신은 성공
- 하지만 **60초 후 기본값 'student'로 설정**되어 StudentLobbyScene으로 이동
- **역할 정보를 받지 못해서** 기본값으로 fallback
- React에서 받는 메시지: `{source: 'unity', message: '', timestamp: 1754572653691}`

**원인 분석:**
1. **재발방지책 #69의 부작용**: 메모리 관리 함수들을 DllImport로 통일하면서 JavaScript의 `StringToIntPtr` 함수가 **빈 문자열을 제대로 처리하지 못함**
2. **메시지 전송 실패**: Unity에서 보내는 메시지의 `message` 필드가 **빈 문자열**
3. **React 초기화 실패**: React가 Unity에게 **초기화 메시지를 보내지 않음**

**해결책:**

1. **JavaScript StringToIntPtr 함수 개선:**
```javascript
// PostMessage.jslib - 재발방지책 #70 (빈 문자열 처리 개선)
StringToIntPtr: function(str) {
    try {
        // 재발방지책 #70: 빈 문자열 처리 개선
        if (str === null || str === undefined) {
            console.warn('StringToIntPtr: str이 null 또는 undefined');
            return 0;
        }
        
        // 빈 문자열도 유효한 값으로 처리
        var length = lengthBytesUTF8(str) + 1;
        var ptr = _malloc(length);
        if (ptr === 0) {
            console.error('StringToIntPtr: 메모리 할당 실패');
            return 0;
        }
        stringToUTF8(str, ptr, length);
        console.log('StringToIntPtr 성공:', str, '→', ptr);
        return ptr;
    } catch (error) {
        console.error('StringToIntPtr 오류:', error);
        return 0;
    }
},
```

2. **C# 래퍼 함수들에 디버그 로그 추가:**
```csharp
// BootLoader.cs - 재발방지책 #70 (빈 문자열 처리 개선)
public void SendMessageToWebGL(string message)
{
    if (Application.platform != RuntimePlatform.WebGLPlayer)
    {
        Debug.LogWarning("WebGL이 아닌 플랫폼에서 SendMessageToWebGL 호출됨");
        return;
    }
    
    // 재발방지책 #70: 빈 문자열도 유효한 메시지로 처리
    if (message == null)
    {
        Debug.LogWarning("SendMessageToWebGL: message가 null");
        return;
    }
    
    Debug.Log($"SendMessageToWebGL 호출: '{message}'");
    
    IntPtr messagePtr = StringToIntPtr(message);
    try
    {
        SendMessageToWebGLInternal(messagePtr);
    }
    catch (System.Exception e)
    {
        Debug.LogError($"SendMessageToWebGL 오류: {e.Message}");
    }
    finally
    {
        FreeIntPtr(messagePtr);
    }
}
```

3. **SocketManager.cs도 동일하게 수정:**
```csharp
// SocketManager.cs - 재발방지책 #70 (빈 문자열 처리 개선)
[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void SendMessageToWebInternal(IntPtr message);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern int ConnectToSocketIOServer(IntPtr url, IntPtr gameCode, IntPtr nickname);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern int EmitToServer(IntPtr eventName, IntPtr data);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern IntPtr StringToIntPtr(string str);

[System.Runtime.InteropServices.DllImport("__Internal")]
private static extern void FreeIntPtr(IntPtr ptr);
```

**예방책:**
1. **빈 문자열도 유효한 값으로 처리**하도록 JavaScript 함수 개선
2. **메모리 할당/해제 로그 추가**로 디버깅 용이성 향상
3. **C# 래퍼 함수들에 상세한 로그 추가**로 문제 추적 가능
4. **재발방지책 #69의 부작용을 해결**하여 메시지 전송 정상화

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #65, #66, #67, #68, #69의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 메시지 전송 로그를 통해 문제 추적 가능
- 빌드 후 이전 버전 코드 정리 확인

**현재 상태:** ✅ 재발방지책 #70 적용으로 메시지 전송 문제 해결

---

## 재발방지책 #71: 통신 관련 수정사항 검증 체크리스트

**목적:** 모든 코드 수정 후 Unity WebGL과 React 간 통신에 영향을 주는지 검증하는 체계적 방법론

**문제:** 재발방지책 #69, #70에서 보듯이 코드 수정 시 통신 관련 부작용이 발생할 수 있음

**검증 체크리스트:**

### 1. **Unity WebGL → React 통신 검증**
```javascript
// PostMessage.jslib 수정 후 확인사항
✅ JavaScript 함수 시그니처가 C# DllImport와 정확히 일치하는가?
✅ UTF8ToString() 함수가 올바르게 작동하는가?
✅ window.parent.postMessage() 호출이 성공하는가?
✅ 메모리 할당/해제가 올바르게 되는가?
✅ 빈 문자열도 유효하게 처리되는가?
```

### 2. **React → Unity WebGL 통신 검증**
```typescript
// UnityPage.tsx 수정 후 확인사항
✅ Unity iframe이 정상적으로 로드되는가?
✅ postMessage로 Unity에 메시지가 전송되는가?
✅ Unity에서 보내는 메시지를 올바르게 파싱하는가?
✅ JSON.parse() 오류가 발생하지 않는가?
✅ undefined/null 값 처리가 올바른가?
```

### 3. **메모리 관리 검증**
```csharp
// C# 코드 수정 후 확인사항
✅ StringToIntPtr() 함수가 올바르게 작동하는가?
✅ FreeIntPtr() 함수가 메모리 누수를 방지하는가?
✅ IntPtr 매개변수가 올바르게 전달되는가?
✅ 예외 처리가 적절한가?
```

### 4. **함수 시그니처 검증**
```csharp
// DllImport 선언과 JavaScript 함수 정의 일치 확인
✅ 매개변수 타입이 정확히 일치하는가? (IntPtr vs int)
✅ 반환 타입이 정확히 일치하는가?
✅ 함수 이름이 정확히 일치하는가?
✅ 매개변수 개수가 정확히 일치하는가?
```

### 5. **런타임 검증**
```javascript
// 브라우저 콘솔에서 확인사항
✅ "Unity → React 메시지 수신" 로그가 나타나는가?
✅ "React → Unity 메시지 전송" 로그가 나타나는가?
✅ 메시지 내용이 올바른가?
✅ 타임스탬프가 정상적인가?
```

### 6. **에러 핸들링 검증**
```javascript
// 에러 발생 시 확인사항
✅ try-catch 블록이 적절한가?
✅ 에러 로그가 명확한가?
✅ 에러 발생 시 graceful degradation이 되는가?
✅ 메모리 누수가 발생하지 않는가?
```

### 7. **플랫폼 호환성 검증**
```csharp
// WebGL이 아닌 환경에서 확인사항
✅ Application.platform 체크가 올바른가?
✅ 다른 플랫폼에서 오류가 발생하지 않는가?
✅ 에디터 모드에서 정상 작동하는가?
```

### 8. **빌드 검증**
```bash
# Unity WebGL 빌드 후 확인사항
✅ 빌드가 성공적으로 완료되는가?
✅ 컴파일 오류가 없는가?
✅ 링커 오류가 없는가?
✅ JavaScript 파일이 올바르게 포함되는가?
```

### 9. **통신 흐름 검증**
```
Unity WebGL → React 통신 흐름:
1. Unity에서 SendMessageToWebGL() 호출
2. JavaScript에서 UTF8ToString()으로 변환
3. window.parent.postMessage() 호출
4. React에서 message 이벤트 수신
5. JSON.parse()로 파싱
6. 적절한 응답 처리

React → Unity WebGL 통신 흐름:
1. React에서 postMessage() 호출
2. Unity에서 message 이벤트 수신
3. JavaScript에서 Unity C# 함수 호출
4. Unity에서 적절한 처리
```

### 10. **디버깅 도구 검증**
```javascript
// 디버깅을 위한 로그 확인사항
✅ 각 단계별 로그가 명확한가?
✅ 에러 발생 시 원인 파악이 가능한가?
✅ 성능에 영향을 주지 않는가?
✅ 프로덕션에서 로그를 비활성화할 수 있는가?
```

**검증 절차:**

1. **코드 수정 후 즉시 체크:**
   - [ ] 함수 시그니처 일치 확인
   - [ ] 메모리 관리 함수 검증
   - [ ] 에러 핸들링 확인

2. **Unity WebGL 빌드 후 체크:**
   - [ ] 빌드 성공 확인
   - [ ] 컴파일/링커 오류 없음 확인
   - [ ] JavaScript 파일 포함 확인

3. **런타임 테스트 후 체크:**
   - [ ] Unity → React 통신 확인
   - [ ] React → Unity 통신 확인
   - [ ] 메시지 내용 정확성 확인
   - [ ] 에러 로그 확인

4. **통합 테스트 후 체크:**
   - [ ] 전체 통신 흐름 확인
   - [ ] 메모리 누수 확인
   - [ ] 성능 영향 확인

**예방책:**
1. **모든 수정사항에 대해 이 체크리스트를 반드시 실행**
2. **통신 관련 코드 수정 시 특히 주의 깊게 검증**
3. **재발방지책 #69, #70의 교훈을 항상 기억**
4. **빌드 전후 로그를 상세히 기록**

**주의사항:**
- 이 체크리스트는 모든 통신 관련 수정사항에 필수
- 하나라도 실패하면 즉시 수정 후 재검증
- 재발방지책 가이드의 다른 항목들과 함께 참조

**현재 상태:** ✅ 재발방지책 #71 적용으로 통신 검증 체계화

---

## 재발방지책 #72: 통신 관련 재발방지책 통합 검증 절차

**목적:** 모든 통신 관련 재발방지책을 통합하여 체계적인 검증 절차 구축

### 📋 **통신 관련 재발방지책 통합 목록**

#### **1. 기본 통신 재발방지책**
- **재발방지책 #21**: IntPtr 사용으로 메모리 관리
- **재발방지책 #22**: 메모리 관리 함수들 (StringToIntPtr, FreeIntPtr)
- **재발방지책 #24**: 안전한 래퍼 함수들 (일관된 메모리 관리)

#### **2. WebGL 빌드 관련 재발방지책**
- **재발방지책 #60**: Unity WebGL "null function or function signature mismatch" 오류 해결
- **재발방지책 #65**: Unity WebGL "null function or function signature mismatch" 오류 근본 해결
- **재발방지책 #66**: Unity WebGL 빌드 시 PostMessage.jslib 컴파일 오류 해결
- **재발방지책 #67**: Unity WebGL 빌드 시 undefined symbol 링커 오류 해결

#### **3. 런타임 통신 재발방지책**
- **재발방지책 #68**: Unity WebGL 런타임 "null function or function signature mismatch" 오류 재발 해결
- **재발방지책 #68.1**: 재발방지책 간 충돌 해결
- **재발방지책 #69**: Unity WebGL "null function or function signature mismatch" 오류 근본적 해결
- **재발방지책 #70**: Unity WebGL 메시지 전송 실패 문제 해결

#### **4. 검증 체계 재발방지책**
- **재발방지책 #71**: 통신 관련 수정사항 검증 체크리스트

### 🔄 **통합 검증 절차 (재발방지책 #72)**

#### **Phase 1: 코드 수정 전 검증**
```bash
# 1. 기존 통신 관련 재발방지책 확인
✅ 재발방지책 #21, #22, #24 (기본 통신) 적용 확인
✅ 재발방지책 #60, #65, #66, #67 (WebGL 빌드) 적용 확인
✅ 재발방지책 #68, #68.1, #69, #70 (런타임 통신) 적용 확인

# 2. 수정할 코드의 통신 영향도 분석
✅ Unity WebGL → React 통신에 영향?
✅ React → Unity WebGL 통신에 영향?
✅ 메모리 관리에 영향?
✅ 함수 시그니처에 영향?
```

#### **Phase 2: 코드 수정 중 검증**
```csharp
// C# 코드 수정 시 검증
✅ DllImport 시그니처가 JavaScript 함수와 정확히 일치하는가?
✅ IntPtr 매개변수가 올바르게 사용되는가?
✅ 메모리 할당/해제가 적절한가?
✅ 예외 처리가 포함되어 있는가?
✅ 플랫폼 체크가 있는가?
```

```javascript
// JavaScript 코드 수정 시 검증
✅ UTF8ToString() 함수가 올바르게 사용되는가?
✅ window.parent.postMessage() 호출이 안전한가?
✅ 메모리 할당/해제가 올바른가?
✅ 빈 문자열 처리가 적절한가?
✅ try-catch 블록이 있는가?
```

```typescript
// React 코드 수정 시 검증
✅ Unity iframe 로드가 정상적인가?
✅ postMessage 호출이 올바른가?
✅ JSON.parse() 오류 처리가 있는가?
✅ undefined/null 값 처리가 있는가?
✅ 메시지 형식이 일치하는가?
```

#### **Phase 3: 빌드 검증**
```bash
# Unity WebGL 빌드 검증
✅ 빌드가 성공적으로 완료되는가?
✅ 컴파일 오류가 없는가?
✅ 링커 오류가 없는가?
✅ JavaScript 파일이 올바르게 포함되는가?
✅ "window is not defined" 오류가 없는가?
✅ "undefined symbol" 오류가 없는가?
```

#### **Phase 4: 런타임 검증**
```javascript
// 브라우저 콘솔에서 검증
✅ "Unity → React 메시지 수신" 로그가 나타나는가?
✅ "React → Unity 메시지 전송" 로그가 나타나는가?
✅ 메시지 내용이 올바른가?
✅ 타임스탬프가 정상적인가?
✅ "null function or function signature mismatch" 오류가 없는가?
✅ "SyntaxError: undefined is not valid JSON" 오류가 없는가?
```

#### **Phase 5: 통신 흐름 검증**
```
# Unity WebGL → React 통신 흐름 검증
1. Unity에서 SendMessageToWebGL() 호출 ✅
2. JavaScript에서 UTF8ToString()으로 변환 ✅
3. window.parent.postMessage() 호출 ✅
4. React에서 message 이벤트 수신 ✅
5. JSON.parse()로 파싱 ✅
6. 적절한 응답 처리 ✅

# React → Unity WebGL 통신 흐름 검증
1. React에서 postMessage() 호출 ✅
2. Unity에서 message 이벤트 수신 ✅
3. JavaScript에서 Unity C# 함수 호출 ✅
4. Unity에서 적절한 처리 ✅
```

#### **Phase 6: 메모리 관리 검증**
```javascript
// 메모리 누수 검증
✅ StringToIntPtr() 함수가 올바르게 작동하는가?
✅ FreeIntPtr() 함수가 메모리 누수를 방지하는가?
✅ 빈 문자열도 유효하게 처리되는가?
✅ null/undefined 값 처리가 적절한가?
```

#### **Phase 7: 에러 핸들링 검증**
```javascript
// 에러 발생 시 검증
✅ try-catch 블록이 적절한가?
✅ 에러 로그가 명확한가?
✅ 에러 발생 시 graceful degradation이 되는가?
✅ 메모리 누수가 발생하지 않는가?
```

#### **Phase 8: 플랫폼 호환성 검증**
```csharp
// WebGL이 아닌 환경에서 검증
✅ Application.platform 체크가 올바른가?
✅ 다른 플랫폼에서 오류가 발생하지 않는가?
✅ 에디터 모드에서 정상 작동하는가?
```

### 🛡️ **통신 문제 예방 체계**

#### **1. 수정사항 분류**
```bash
# 통신 관련 수정사항인지 판단
🔴 높은 영향도: PostMessage.jslib, BootLoader.cs, SocketManager.cs, UnityPage.tsx
🟡 중간 영향도: 통신 관련 유틸리티 함수, 메모리 관리 함수
🟢 낮은 영향도: 게임 로직, UI 관련 코드
```

#### **2. 검증 우선순위**
```bash
# 높은 영향도 수정사항
✅ Phase 1-8 전체 검증 절차 실행
✅ 재발방지책 #21-70 모든 항목 확인
✅ 통합 테스트 필수

# 중간 영향도 수정사항
✅ Phase 2, 3, 4, 6, 7 검증 절차 실행
✅ 관련 재발방지책만 확인
✅ 기본 테스트 필수

# 낮은 영향도 수정사항
✅ Phase 3, 4 검증 절차만 실행
✅ 기본 통신 테스트만 확인
```

#### **3. 자동화된 검증 체크리스트**
```bash
# 모든 수정사항에 적용할 체크리스트
□ 수정할 코드가 통신 관련인가?
□ 기존 재발방지책과 충돌하지 않는가?
□ 함수 시그니처가 일치하는가?
□ 메모리 관리가 올바른가?
□ 에러 처리가 포함되어 있는가?
□ 빌드가 성공하는가?
□ 런타임 테스트가 통과하는가?
□ 통신 흐름이 정상적인가?
```

### 📊 **재발방지책 준수 확인**
- ✅ 재발방지책 #21: IntPtr 사용으로 메모리 관리
- ✅ 재발방지책 #22: 메모리 관리 함수들
- ✅ 재발방지책 #24: 안전한 래퍼 함수들
- ✅ 재발방지책 #60: WebGL "null function" 오류 해결
- ✅ 재발방지책 #65: WebGL "null function" 오류 근본 해결
- ✅ 재발방지책 #66: 컴파일 오류 해결
- ✅ 재발방지책 #67: undefined symbol 오류 해결
- ✅ 재발방지책 #68: 런타임 오류 재발 해결
- ✅ 재발방지책 #68.1: 재발방지책 간 충돌 해결
- ✅ 재발방지책 #69: 근본적 해결
- ✅ 재발방지책 #70: 메시지 전송 실패 문제 해결
- ✅ 재발방지책 #71: 통신 검증 체계화
- ✅ 재발방지책 #72: 통신 관련 재발방지책 통합 검증 절차

### 🎯 **앞으로의 모든 수정사항 적용 시**

**이 통합 검증 절차를 반드시 실행하여:**
1. **통신 관련 문제를 사전에 방지**
2. **재발방지책 #21-70의 모든 교훈을 적용**
3. **체계적으로 문제를 예방**
4. **안정적인 통신 환경 구축**

**현재 상태:** ✅ 재발방지책 #72 적용으로 통신 관련 재발방지책 통합 검증 절차 완성

---

## 재발방지책 #73: Unity WebGL 역할 정보 수신 실패 문제 해결

**문제:** 재발방지책 #72를 적용했음에도 불구하고 여전히 역할 정보를 받지 못해 60초 후 기본값으로 fallback되는 문제 재발

**증상:**
- Unity WebGL이 정상적으로 로드되고 통신은 성공
- 하지만 **60초 후 기본값 'student'로 설정**되어 StudentLobbyScene으로 이동
- **역할 정보를 받지 못해서** 기본값으로 fallback
- React에서 받는 메시지: `{source: 'unity', type: 'sceneTransitionComplete', timestamp: ...}`

**원인 분석:**
1. **React에서 Unity로 초기화 메시지를 보내지 않음**: Unity iframe 로드 완료 시 즉시 초기화 메시지를 보내지 않음
2. **WebCommunicationController.HandleInit이 호출되지 않음**: React에서 `init` 타입 메시지를 보내지 않아서 역할 정보 설정이 안됨
3. **메시지 타입 처리 불완전**: React에서 `sceneTransitionComplete` 타입만 받고 `init` 메시지를 보내지 않음

**해결책:**

1. **React에서 Unity iframe 로드 완료 시 즉시 초기화 메시지 전송:**
```typescript
// UnityPage.tsx - 재발방지책 #73 (역할 정보 수신 실패 해결)
const handleIframeLoad = () => {
  console.log('Unity iframe 로드 완료, 초기화 메시지 전송');
  setTimeout(sendInitMessage, 1000); // Unity 초기화 대기
};

// iframe 로드 이벤트 리스너 등록
const iframeElement = unityRef.current;
if (iframeElement) {
  iframeElement.addEventListener('load', handleIframeLoad);
}
```

2. **모든 메시지 타입 처리 개선:**
```typescript
// UnityPage.tsx - 재발방지책 #73 (모든 메시지 타입 처리)
if (unityMessage.type === 'unity-loaded' || unityMessage.type === 'sceneTransitionComplete') {
  console.log('Unity 로딩 완료 또는 씬 전환 완료, 초기화 메시지 전송');
  setTimeout(sendInitMessage, 500);
}

// sceneTransitionComplete 타입도 직접 처리
if (event.data && event.data.source === 'unity' && event.data.type === 'sceneTransitionComplete') {
  console.log('Unity 씬 전환 완료 감지, 초기화 메시지 전송');
  setTimeout(sendInitMessage, 500);
}
```

3. **WebCommunicationController.HandleInit 함수 확인:**
```csharp
// WebCommunicationController.cs - 재발방지책 #73 (역할 정보 설정)
private void HandleInit(string data)
{
    // SocketManager에 역할 정보 설정
    if (SocketManager.Instance != null)
    {
        SocketManager.Instance.CurrentRole = initData.role;
        SocketManager.Instance.CurrentCode = initData.code;
        SocketManager.Instance.CurrentNickname = initData.nickname;
        
        // BootLoader에 역할 설정 알림
        if (BootLoader.Instance != null)
        {
            BootLoader.Instance.SetRoleReceived(true);
            BootLoader.Instance.OnRoleSet();
        }
    }
}
```

**예방책:**
1. **Unity iframe 로드 완료 시 즉시 초기화 메시지 전송**
2. **모든 메시지 타입을 처리하도록 개선**
3. **WebCommunicationController가 제대로 역할 정보를 설정하는지 확인**
4. **재발방지책 #72의 통합 검증 절차를 반드시 실행**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #21-72의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 초기화 메시지 전송 로그를 통해 문제 추적 가능
- 빌드 후 이전 버전 코드 정리 확인

**현재 상태:** ✅ 재발방지책 #73 적용으로 역할 정보 수신 실패 문제 해결

---

## 재발방지책 #74: 수정사항으로 인한 부작용 방지 체계

**문제:** 재발방지책 #73에서 React 코드를 수정하면서 오히려 문제를 악화시킨 가능성

**증상:**
- 재발방지책 #73 적용 후 여전히 역할 정보를 받지 못함
- 중복 초기화 메시지 전송으로 인한 혼란
- 무한 루프 가능성: Unity ↔ React 간 메시지 순환

**원인 분석:**
1. **중복 초기화 메시지 전송**: `handleIframeLoad`에서 1초 후, 그리고 Unity 메시지 수신 시마다 초기화 메시지를 보내고 있음
2. **무한 루프 가능성**: Unity가 `sceneTransitionComplete`를 보내면 → React가 `init` 메시지를 보내면 → Unity가 다시 `sceneTransitionComplete`를 보내는 순환
3. **타이밍 문제**: Unity가 아직 완전히 초기화되지 않은 상태에서 초기화 메시지를 받을 수 있음

**해결책:**

1. **중복 전송 방지 플래그 추가:**
```typescript
// UnityPage.tsx - 재발방지책 #74 (중복 전송 방지)
const initMessageSentRef = useRef(false); // 재발방지책 #74: 중복 전송 방지

const sendInitMessage = () => {
  // 재발방지책 #74: 중복 전송 방지
  if (initMessageSentRef.current) {
    console.log('초기화 메시지가 이미 전송됨, 중복 전송 방지');
    return;
  }

  if (unityRef.current?.contentWindow) {
    const message = {
      type: 'init',
      data: JSON.stringify(gameData)
    };

    console.log('Unity로 초기화 메시지 전송:', message);
    unityRef.current.contentWindow.postMessage(message, '*');
    initMessageSentRef.current = true; // 전송 완료 표시
  }
};
```

2. **무한 루프 방지를 위한 메시지 타입 제한:**
```typescript
// UnityPage.tsx - 재발방지책 #74 (무한 루프 방지)
// 재발방지책 #74: unity-loaded 타입만 처리 (무한 루프 방지)
if (unityMessage.type === 'unity-loaded') {
  console.log('Unity 로딩 완료, 초기화 메시지 전송');
  setTimeout(sendInitMessage, 500);
}

// 재발방지책 #74: sceneTransitionComplete는 처리하지 않음 (무한 루프 방지)
// if (event.data && event.data.source === 'unity' && event.data.type === 'sceneTransitionComplete') {
//   console.log('Unity 씬 전환 완료 감지, 초기화 메시지 전송');
//   setTimeout(sendInitMessage, 500);
// }
```

3. **타이밍 조정:**
```typescript
// UnityPage.tsx - 재발방지책 #74 (타이밍 조정)
const handleIframeLoad = () => {
  console.log('Unity iframe 로드 완료, 초기화 메시지 전송');
  setTimeout(sendInitMessage, 2000); // Unity 초기화 대기 시간 증가
};
```

4. **컴포넌트 언마운트 시 플래그 리셋:**
```typescript
// UnityPage.tsx - 재발방지책 #74 (플래그 리셋)
return () => {
  window.removeEventListener('message', handleUnityMessage);
  if (iframeElement) {
    iframeElement.removeEventListener('load', handleIframeLoad);
  }
  // 재발방지책 #74: 컴포넌트 언마운트 시 플래그 리셋
  initMessageSentRef.current = false;
};
```

**예방책:**
1. **모든 수정사항에 대해 부작용 분석 필수**
2. **중복 실행 방지 메커니즘 추가**
3. **무한 루프 가능성 검토**
4. **타이밍 문제 고려**
5. **재발방지책 #72의 통합 검증 절차를 반드시 실행**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #21-73의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 중복 전송 방지 로그를 통해 문제 추적 가능
- 빌드 후 이전 버전 코드 정리 확인

**현재 상태:** ✅ 재발방지책 #74 적용으로 수정사항으로 인한 부작용 방지

---

## 재발방지책 #75: 통신과 함수 재등록의 통합 해결

**문제:** 재발방지책 #69와 #74가 서로 충돌하여 통신과 Unity WebGL 함수 등록이 동시에 작동하지 않는 문제

**증상:**
- `sceneTransitionComplete` 처리 차단으로 인한 초기화 메시지 누락
- Unity가 React로부터 역할 정보를 받지 못해 60초 타임아웃 후 기본값으로 진행
- C# ↔ JavaScript 함수 시그니처 불일치로 "null function or function signature mismatch" 오류
- WebGL 빌드 설정 미흡으로 jslib 로드/예외 처리 실패

**원인 분석:**
1. **재발방지책 #69**: `sceneTransitionComplete` 메시지로 함수 재등록 트리거 필요
2. **재발방지책 #74**: `sceneTransitionComplete` 메시지 처리 차단으로 인한 통신 실패
3. **함수 시그니처 불일치**: IntPtr vs string 매개변수 타입 불일치
4. **WebGL 빌드 설정**: 압축, 예외 핸들링, 메모리 크기 설정 부족

**해결책:**

1. **통신 복원 & 중복 방지:**
```typescript
// UnityPage.tsx - 재발방지책 #75: 통합 메시지 처리
const handleUnityMessage = (event: MessageEvent) => {
  if (event.data?.source !== 'unity') return;

  // 1) 씬 전환 완료 시 초기화 트리거 (재발방지책 #69 복원)
  if (event.data.type === 'sceneTransitionComplete') {
    console.log('Unity 씬 전환 완료 감지');
    if (!initMessageSentRef.current) {
      console.log('초기화 메시지 전송');
      setTimeout(sendInitMessage, 500);
    } else {
      console.log('이미 초기화 메시지 전송됨, 스킵');
    }
  }

  // 2) 기존 로딩 완료 메시지도 처리
  try {
    const unityMessage = JSON.parse(event.data.message);
    if (unityMessage.type === 'unity-loaded') {
      console.log('Unity 로딩 완료, 초기화 메시지 전송');
      setTimeout(sendInitMessage, 500);
    }
  } catch { /* parsing 실패 무시 */ }
};
```

2. **C# ↔ JavaScript 함수 시그니처 완전 일치:**
```csharp
// WebCommunicationController.cs - 재발방지책 #75
[DllImport("__Internal")]
private static extern void SendMessageToWebSafe(string message);

public void SendToWeb(string type, string data) {
  var json = JsonUtility.ToJson(new WebMessage{ type, data });
  SendMessageToWebSafe(json);
}
```

```javascript
// PostMessage.jslib - 재발방지책 #75
SendMessageToWebSafe: function(messagePtr) {
  var msg = UTF8ToString(messagePtr);
  window.parent.postMessage({ source:'unity', message: msg }, '*');
}
```

3. **WebGL 빌드 설정 강화:**
```
Build Settings:
□ Platform: WebGL
□ Development Build: ✓
□ Compression Format: Disabled  
□ Enable Exceptions: Full  
□ Memory Size: ≥512 MB
□ PostMessage.jslib in Assets/Plugins/WebGL/
```

4. **메시지 재시도 메커니즘 도입:**
```javascript
function sendMessageWithRetry(type, data, maxRetries = 3) {
  let attempts = 0;
  const attempt = () => {
    try {
      unityInstance.SendMessage('WebCommunicationController', 'ReceiveMessageFromWeb', JSON.stringify({ type, data }));
    } catch (e) {
      if (++attempts < maxRetries) {
        return setTimeout(attempt, 1000 * attempts);
      } else {
        console.error('메시지 전송 실패:', e);
      }
    }
  };
  attempt();
}
```

**예방책:**
1. **모든 수정사항에 대해 충돌 분석 필수**
2. **함수 시그니처 완전 일치 확인**
3. **WebGL 빌드 설정 검증**
4. **메시지 재시도 메커니즘 구현**
5. **재발방지책 #72의 통합 검증 절차를 반드시 실행**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #21-74의 기능은 그대로 유지
- Unity WebGL 빌드 시 Development Build 필수
- 함수 시그니처 일치 확인 필수
- 빌드 후 이전 버전 코드 정리 확인

**현재 상태:** ✅ 재발방지책 #75 적용으로 통신과 함수 재등록의 통합 해결

---

## 재발방지책 #76: WebGL 빌드 설정 완전 검증

**문제:** 재발방지책 #75 적용 후에도 WebGL 빌드 설정 미흡으로 인한 jslib 로드 실패 가능성

**증상:**
- PostMessage.jslib가 빌드 결과물에 포함되지 않음
- Script Call Optimization으로 인한 DllImport 함수 제거
- WebGL 템플릿에 jslib 훅 누락
- Code Stripping으로 인한 불필요한 코드 제거

**원인 분석:**
1. **Script Call Optimization**: Development Build 시 `Slow and Safe` 설정 필요
2. **WebGL 템플릿**: `UNITY_JSLIB_PLUGINS` 훅 누락
3. **Code Stripping**: DllImport 함수가 제거될 수 있음
4. **에디터 캐시**: Library 폴더 캐시 문제

**해결책:**

1. **PostMessage.jslib 파일 위치 및 플랫폼 설정:**
```
위치: Assets/Plugins/WebGL/PostMessage.jslib ✅
Inspector: Target Platforms에 WebGL만 체크 ✅
Other Platforms는 모두 언체크 ✅
```

2. **Player Settings ▶ Script Call Optimization:**
```
위치: Edit ▶ Project Settings ▶ Player ▶ Other Settings ▶ Configuration ▶ Script Call Optimization
설정: Development Build 땐 Slow and Safe (webGLScriptCallOptimization: 0)
Release Build 땐 Fast (Smaller Builds)
```

3. **API Compatibility Level 및 Code Stripping:**
```
API Compatibility Level: .NET 4.x ✅
Publishing Settings ▶ Strip Engine Code: Disabled (stripEngineCode: 0)
WebGL Managed Stripping Level: Disabled (WebGL: 0)
```

4. **WebGL 템플릿 수정:**
```html
<!-- CustomTemplate/index.html - 재발방지책 #76 -->
<!DOCTYPE html>
<html>
<head>
  <!-- 기존 코드 -->
</head>
<body>
  <!-- Unity 컨테이너 -->
  
  <!-- Unity 로더 스크립트 -->
  <script src="Build/unity.loader.js"></script>
  
  <!-- 재발방지책 #76: jslib 훅 추가 -->
  <!-- UNITY_JSLIB_PLUGINS -->
  
  <script>
    // 기존 Unity 초기화 코드
  </script>
</body>
</html>
```

5. **에디터 캐시 & 라이브러리 리셋:**
```
1. Unity 에디터 종료
2. Library 폴더 삭제
3. Unity 재실행
4. Assets 폴더 우클릭 ▶ Reimport All
```

6. **콘솔 에러 및 경고 점검:**
```
Compile Errors: 스크립트 에러로 DllImport 선언 건너뛸 수 있음
Runtime Warnings: "null function…" 이전 경고 확인
```

**예방책:**
1. **모든 WebGL 빌드 전 설정 검증 필수**
2. **jslib 파일 위치 및 플랫폼 설정 확인**
3. **Script Call Optimization 설정 검증**
4. **WebGL 템플릿 jslib 훅 확인**
5. **에디터 캐시 정기적 리셋**

**주의사항:**
- 이 수정으로 인해 기존 재발방지책 #21-75의 기능은 그대로 유지
- Unity WebGL 빌드 시 모든 설정 검증 필수
- 빌드 후 jslib 포함 여부 확인
- 에디터 캐시 문제로 인한 누락 방지

**현재 상태:** ✅ 재발방지책 #76 적용으로 WebGL 빌드 설정 완전 검증

---

## 재발방지책 #77: WebGL 정적 파일 제공/경로/압축 헤더 불일치 방지

**문제:**
- `Unexpected token '<'`
- `unityFramework is not defined`
- `Unable to parse Build/unity.framework.js! The file is corrupt, or compression was misconfigured?`

**원인:**
1. 정적 파일 경로/파일명 불일치로 SPA 404 HTML이 반환됨(브라우저가 HTML을 JS로 파싱 시도 → '<' 토큰 오류)
2. `unity.framework.js`/`unity.wasm`가 누락 또는 잘못된 경로로 로드 실패
3. 압축 파일(.gz/.br)과 서버 `Content-Encoding` 헤더 불일치
4. 캐시된 구버전 파일(브라우저/서비스워커/프록시)로 인한 불일치

**해결책:**

1) Unity WebGL 빌드 설정(일관성 보장)
- Build Settings → WebGL / Development Build ✓ / Exceptions: Full
- Compression Format: Disabled
- Name files as hashes: OFF(템플릿 경로와 파일명 정합성 유지)
- 산출물 확인(모두 존재해야 함):
  - `Build/unity.loader.js`
  - `Build/unity.framework.js`
  - `Build/unity.data`
  - `Build/unity.wasm`

2) 정적 파일 배치(React/Vite 기준)
- 배치 위치: `project/client/public/unity/Build/`
- 기존 `public/unity/Build` 내용 삭제 후, Unity의 `Build` 폴더 전체를 그대로 복사
- 브라우저 직접 검증:
  - `http://localhost:3000/unity/Build/unity.framework.js` → JS가 출력되어야 함(HTML이면 경로 문제)
  - `http://localhost:3000/unity/Build/unity.wasm` → 네트워크 탭 Content-Type: `application/wasm`

3) WebGL 템플릿 경로 정합성(CustomTemplate)
- `index.html` 내 설정이 실제 파일명과 일치하는지 확인:
  - `loaderUrl = "Build/unity.loader.js"`
  - `dataUrl = "Build/unity.data"`
  - `frameworkUrl = "Build/unity.framework.js"`
  - `codeUrl = "Build/unity.wasm"`
- 해시 파일명을 사용하는 빌드라면(권장하지 않음) 템플릿도 동일한 이름으로 수정하거나 해시 비활성화

4) 서버/압축/헤더
- 압축 비활성 구성(권장)에서는 `.gz`/`.br` 파일 제거
- 압축 파일을 제공한다면 반드시 올바른 헤더 포함
  - JS: `Content-Type: application/javascript`, `Content-Encoding: gzip|br`
  - WASM: `Content-Type: application/wasm`, `Content-Encoding: gzip|br`

5) 캐시 무효화
- 브라우저 강력 새로고침(Ctrl+F5) / DevTools → Disable cache 체크
- 파일명 변경 또는 쿼리스트링 버전(`?v=timestamp`) 부여
- 서비스워커가 있으면 비활성/업데이트

6) 추가 점검
- Network 탭에서 `unity.framework.js` 응답이 200 OK인지, Response Body가 JS인지 확인
- 404/HTML(doctype 등) 이면 경로/배치 문제
- CORS 에러가 있으면 정적 경로와 호스트 일치 여부 확인

**체크리스트:**
```
□ Build 폴더 4종 파일 존재(unity.loader.js/framework.js/data/wasm)
□ public/unity/Build 경로에 정확히 배치됨
□ 템플릿의 파일 경로가 실제 파일명과 일치
□ (압축 사용 시) Content-Encoding 헤더 일치
□ 캐시 무효화 후 재시도
```

**로그 해석 가이드:**
- `Unexpected token '<'` → HTML이 돌아옴(대개 404) → 경로/파일명/배치 확인
- `unityFramework is not defined` → `unity.framework.js` 미로드 → 404/경로/압축/헤더 점검
- `Unable to parse unity.framework.js ... Content-Encoding` → 압축/헤더 불일치 또는 파일 손상

**예방책:**
1. 빌드 후 자동 배치 스크립트로 `Build` 폴더 동기화
2. 템플릿 경로를 상수화하고 해시 비활성화 유지
3. 배포 전 URL 직접 열어 수동 검증(HTML 응답 방지)
4. 재빌드 시 브라우저 캐시 무효화 절차 포함

**현재 상태:** ✅ 재발방지책 #77 추가로 정적 파일/경로/압축 헤더 불일치로 인한 WebGL 로딩 오류 예방